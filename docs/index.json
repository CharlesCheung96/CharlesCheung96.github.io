[{"categories":["Java"],"content":"转载","date":"2021-07-22","objectID":"/2021/can_you_write_java/","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"[TOC] 细思极恐-你真的会写java吗? 导语 自2013年毕业后，今年已经是我工作的第4个年头了，总在做java相关的工作，终于有时间坐下来，写一篇关于java写法的一篇文章，来探讨一下如果你真的是一个java程序员，那你真的会写java吗? 笔者是一个务实的程序员，故本文绝非扯淡文章，文中内容都是干货，望读者看后，能有所收获。 文章核心 其实，本不想把标题写的那么恐怖，只是发现很多人干了几年java以后，都自认为是一个不错的java程序员了，可以拿着上万的工资都处宣扬自己了，写这篇文章的目的并不是嘲讽和我一样做java的同行们，只是希望读者看到此骗文章后，可以和我一样，心平气和的争取做一个优秀的程序员。 ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:0:0","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"讲述方向 由于一直从事移动互联网相关工作，java开发中经常和移动端打交道或者做一些后端的工作，所以本篇文章更可能涉及和移动端的交互或者与后端的交互方式，笔者希望以自身的一些学习经验或者开发经验，可以带动认真阅读本篇文章的读者们，让大家对java有一个更好的态度去学习它，它不只是一个赚钱的工具而已。 笔者身边有很多与笔者年龄相仿或年龄更大的朋友或同事，经常有人问我：“你现在还在学习吗？我觉得没什么好学的，这些东西都差不多”，我总是回答只要有时间，我就要看一会书，这个时候，大家都会露出一副不屑的眼神或笑容。其实，非常能理解身边朋友或同事的看法，以目前状态来讲，大多都是工作至少5年的程序员了，对于公司大大小小的业务需要，以目前的知识储备来讲，都可以轻松应对，“没有什么好学的”其实这句话没有多大的问题，但是，如果你对编程还有一点点兴趣，只是不知道如何努力或改进，希望本篇文章可以帮到你。 ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:1:0","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"技术点 本文不是一个吹嘘的文章，不会讲很多高深的架构，相反，会讲解很多基础的问题和写法问题，如果读者自认为基础问题和写法问题都是不是问题，那请忽略这篇文章，节省出时间去做一些有意义的事情。 开发工具 不知道有多少”老”程序员还在使用eclipse，这些程序员们要不就是因循守旧，要不就是根本就不知道其他好的开发工具的存在，eclipse吃内存卡顿的现象以及各种偶然莫名异常的出现，都告知我们是时候寻找新的开发工具了。 ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:2:0","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"更换IDE 根本就不想多解释要换什么样的IDE，如果你想成为一个优秀的java程序员，请更换intellij idea. 使用idea的好处，请搜索谷歌。 ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:3:0","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"别告诉我快捷键不好用 更换IDE不在我本文的重点内容中，所以不下想用太多的篇幅去写为什么更换IDE，请谷歌。 在这里，我只能告诉你，更换IDE只为了更好、更快的写好java代码。原因略。 别告诉我快捷键不好用，请尝试新事物。 bean bean使我们使用最多的模型之一，我将以大篇幅去讲解bean，希望读者好好体会。 ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:4:0","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"domain包名 根据很多java程序员的”经验”来看，一个数据库表则对应着一个domain对象，所以很多程序员在写代码时，包名则使用：com.xxx.domain ，这样写好像已经成为了行业的一种约束，数据库映射对象就应该是domain。但是你错了，domain是一个领域对象，往往我们再做传统java软件web开发中，这些domain都是贫血模型，是没有行为的，或是没有足够的领域模型的行为的，所以，以这个理论来讲，这些domain都应该是一个普通的entity对象，并非领域对象，所以请把包名改为:com.xxx.entity。 如果你还不理解我说的话，请看一下Vaughn Vernon出的一本叫做《IMPLEMENTING DOMAIN-DRIVEN DESIGN》(实现领域驱动设计)这本书，书中讲解了贫血模型与领域模型的区别，相信你会受益匪浅。 ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:5:0","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"DTO 数据传输我们应该使用DTO对象作为传输对象，这是我们所约定的，因为很长时间我一直都在做移动端api设计的工作，有很多人告诉我，他们认为只有给手机端传输数据的时候(input or output)，这些对象成为DTO对象。请注意！这种理解是错误的，只要是用于网络传输的对象，我们都认为他们可以当做是DTO对象，比如电商平台中，用户进行下单，下单后的数据，订单会发到OMS 或者 ERP系统，这些对接的返回值以及入参也叫DTO对象。 我们约定某对象如果是DTO对象，就将名称改为XXDTO,比如订单下发OMS：OMSOrderInputDTO。 ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:6:0","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"DTO转化 正如我们所知，DTO为系统与外界交互的模型对象，那么肯定会有一个步骤是将DTO对象转化为BO对象或者是普通的entity对象，让service层去处理。 ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:7:0","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"场景 比如添加会员操作，由于用于演示，我只考虑用户的一些简单数据，当后台管理员点击添加用户时，只需要传过来用户的姓名和年龄就可以了，后端接受到数据后，将添加创建时间和更新时间和默认密码三个字段，然后保存数据库。 @RequestMapping(\"/v1/api/user\") @RestController public class UserApi { @Autowired private UserService userService; @PostMapping public User addUser(UserInputDTO userInputDTO){ User user = new User(); user.setUsername(userInputDTO.getUsername()); user.setAge(userInputDTO.getAge()); return userService.addUser(user); } } 我们只关注一下上述代码中的转化代码，其他内容请忽略: User user = new User(); user.setUsername(userInputDTO.getUsername()); user.setAge(userInputDTO.getAge()); ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:7:1","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"请使用工具 上边的代码，从逻辑上讲，是没有问题的，只是这种写法让我很厌烦，例子中只有两个字段，如果有20个字段，我们要如何做呢？ 一个一个进行set数据吗？当然，如果你这么做了，肯定不会有什么问题，但是，这肯定不是一个最优的做法。 网上有很多工具，支持浅拷贝或深拷贝的Utils. 举个例子，我们可以使用org.springframework.beans.BeanUtils#copyProperties对代码进行重构和优化: @PostMapping public User addUser(UserInputDTO userInputDTO){ User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return userService.addUser(user); } BeanUtils.copyProperties是一个浅拷贝方法，复制属性时，我们只需要把DTO对象和要转化的对象两个的属性值设置为一样的名称，并且保证一样的类型就可以了。如果你在做DTO转化的时候一直使用set进行属性赋值，那么请尝试这种方式简化代码，让代码更加清晰! ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:7:2","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"转化的语义 上边的转化过程，读者看后肯定觉得优雅很多，但是我们再写java代码时，更多的需要考虑语义的操作，再看上边的代码: User user = new User(); BeanUtils.copyProperties(userInputDTO,user); 虽然这段代码很好的简化和优化了代码，但是他的语义是有问题的，我们需要提现一个转化过程才好,所以代码改成如下: @PostMapping public User addUser(UserInputDTO userInputDTO){ User user = convertFor(userInputDTO); return userService.addUser(user); } private User convertFor(UserInputDTO userInputDTO){ User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; } 这是一个更好的语义写法，虽然他麻烦了些，但是可读性大大增加了，在写代码时，我们应该尽量把语义层次差不多的放到一个方法中，比如: User user = convertFor(userInputDTO); return userService.addUser(user); 这两段代码都没有暴露实现，都是在讲如何在同一个方法中，做一组相同层次的语义操作，而不是暴露具体的实现。 如上所述，是一种重构方式，读者可以参考Martin Fowler的《Refactoring Imporving the Design of Existing Code》(重构 改善既有代码的设计) 这本书中的Extract Method重构方式。 ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:7:3","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"抽象接口定义 当实际工作中，完成了几个api的DTO转化时，我们会发现，这样的操作有很多很多，那么应该定义好一个接口，让所有这样的操作都有规则的进行。 如果接口被定义以后，那么convertFor这个方法的语义将产生变化，他将是一个实现类。 看一下抽象后的接口: public interface DTOConvert\u003cS,T\u003e { T convert(S s); } 虽然这个接口很简单，但是这里告诉我们一个事情，要去使用泛型，如果你是一个优秀的java程序员，请为你想做的抽象接口，做好泛型吧。 我们再来看接口实现: public class UserInputDTOConvert implements DTOConvert { @Override public User convert(UserInputDTO userInputDTO) { User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; } } 我们这样重构后，我们发现现在的代码是如此的简洁，并且那么的规范: @RequestMapping(\"/v1/api/user\") @RestController public class UserApi { @Autowired private UserService userService; @PostMapping public User addUser(UserInputDTO userInputDTO){ User user = new UserInputDTOConvert().convert(userInputDTO); return userService.addUser(user); } } ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:7:4","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"review code 如果你是一个优秀的java程序员，我相信你应该和我一样，已经数次重复review过自己的代码很多次了。 我们再看这个保存用户的例子，你将发现，api中返回值是有些问题的，问题就在于不应该直接返回User实体，因为如果这样的话，就暴露了太多实体相关的信息，这样的返回值是不安全的，所以我们更应该返回一个DTO对象，我们可称它为UserOutputDTO: @PostMapping public UserOutputDTO addUser(UserInputDTO userInputDTO){ User user = new UserInputDTOConvert().convert(userInputDTO); User saveUserResult = userService.addUser(user); UserOutputDTO result = new UserOutDTOConvert().convertToUser(saveUserResult); return result; } 这样你的api才更健全。 不知道在看完这段代码之后，读者有是否发现还有其他问题的存在，作为一个优秀的java程序员，请看一下这段我们刚刚抽象完的代码: User user = new UserInputDTOConvert().convert(userInputDTO); 你会发现，new这样一个DTO转化对象是没有必要的，而且每一个转化对象都是由在遇到DTO转化的时候才会出现，那我们应该考虑一下，是否可以将这个类和DTO进行聚合呢，看一下我的聚合结果: public class UserInputDTO { private String username; private int age; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public User convertToUser(){ UserInputDTOConvert userInputDTOConvert = new UserInputDTOConvert(); User convert = userInputDTOConvert.convert(this); return convert; } private static class UserInputDTOConvert implements DTOConvert\u003cUserInputDTO,User\u003e { @Override public User convert(UserInputDTO userInputDTO) { User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; } } } 然后api中的转化则由: User user = new UserInputDTOConvert().convert(userInputDTO); User saveUserResult = userService.addUser(user); 变成了: User user = userInputDTO.convertToUser(); User saveUserResult = userService.addUser(user); 我们再DTO对象中添加了转化的行为，我相信这样的操作可以让代码的可读性变得更强，并且是符合语义的。 ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:7:5","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"再查工具类 再来看DTO内部转化的代码，它实现了我们自己定义的DTOConvert接口，但是这样真的就没有问题，不需要再思考了吗？ 我觉得并不是，对于Convert这种转化语义来讲，很多工具类中都有这样的定义，这中Convert并不是业务级别上的接口定义，它只是用于普通bean之间转化属性值的普通意义上的接口定义，所以我们应该更多的去读其他含有Convert转化语义的代码。 我仔细阅读了一下GUAVA的源码，发现了com.google.common.base.Convert这样的定义: public abstract class Converter\u003cA, B\u003e implements Function\u003cA, B\u003e { protected abstract B doForward(A a); protected abstract A doBackward(B b); //其他略 } 从源码可以了解到，GUAVA中的Convert可以完成正向转化和逆向转化，继续修改我们DTO中转化的这段代码: private static class UserInputDTOConvert implements DTOConvert\u003cUserInputDTO,User\u003e { @Override public User convert(UserInputDTO userInputDTO) { User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; } } 修改后: private static class UserInputDTOConvert extends Converter\u003cUserInputDTO, User\u003e { @Override protected User doForward(UserInputDTO userInputDTO) { User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; } @Override protected UserInputDTO doBackward(User user) { UserInputDTO userInputDTO = new UserInputDTO(); BeanUtils.copyProperties(user,userInputDTO); return userInputDTO; } } 看了这部分代码以后，你可能会问，那逆向转化会有什么用呢？其实我们有很多小的业务需求中，入参和出参是一样的，那么我们变可以轻松的进行转化，我将上边所提到的UserInputDTO和UserOutputDTO都转成UserDTO展示给大家: DTO： public class UserDTO { private String username; private int age; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public User convertToUser(){ UserDTOConvert userDTOConvert = new UserDTOConvert(); User convert = userDTOConvert.convert(this); return convert; } public UserDTO convertFor(User user){ UserDTOConvert userDTOConvert = new UserDTOConvert(); UserDTO convert = userDTOConvert.reverse().convert(user); return convert; } private static class UserDTOConvert extends Converter\u003cUserDTO, User\u003e { @Override protected User doForward(UserDTO userDTO) { User user = new User(); BeanUtils.copyProperties(userDTO,user); return user; } @Override protected UserDTO doBackward(User user) { UserDTO userDTO = new UserDTO(); BeanUtils.copyProperties(user,userDTO); return userDTO; } } } api: @PostMapping public UserDTO addUser(UserDTO userDTO){ User user = userDTO.convertToUser(); User saveResultUser = userService.addUser(user); UserDTO result = userDTO.convertFor(saveResultUser); return result; } 当然，上述只是表明了转化方向的正向或逆向，很多业务需求的出参和入参的DTO对象是不同的，那么你需要更明显的告诉程序：逆向是无法调用的: private static class UserDTOConvert extends Converter\u003cUserDTO, User\u003e { @Override protected User doForward(UserDTO userDTO) { User user = new User(); BeanUtils.copyProperties(userDTO,user); return user; } @Override protected UserDTO doBackward(User user) { throw new AssertionError(\"不支持逆向转化方法!\"); } } 看一下doBackward方法，直接抛出了一个断言异常，而不是业务异常，这段代码告诉代码的调用者，这个方法不是准你调用的，如果你调用，我就”断言”你调用错误了。 关于异常处理的更详细介绍，可以参考我之前的文章:如何优雅的设计java异常 ，应该可以帮你更好的理解异常。 ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:7:6","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"bean的验证 如果你认为我上边写的那个添加用户api写的已经非常完美了，那只能说明你还不是一个优秀的程序员。我们应该保证任何数据的入参到方法体内都是合法的。 ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:8:0","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"为什么要验证 很多人会告诉我，如果这些api是提供给前端进行调用的，前端都会进行验证啊，你为什还要验证？ 其实答案是这样的，我从不相信任何调用我api或者方法的人，比如前端验证失败了，或者某些人通过一些特殊的渠道(比如Charles进行抓包),直接将数据传入到我的api，那我仍然进行正常的业务逻辑处理，那么就有可能产生脏数据！ “对于脏数据的产生一定是致命”，这句话希望大家牢记在心，再小的脏数据也有可能让你找几个通宵！ ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:8:1","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"jsr 303验证 hibernate提供的jsr 303实现，我觉得目前仍然是很优秀的，具体如何使用，我不想讲，因为谷歌上你可以搜索出很多答案! 再以上班的api实例进行说明，我们现在对DTO数据进行检查: public class UserDTO { @NotNull private String username; @NotNull private int age; //其他代码略 } api验证: @PostMapping public UserDTO addUser(@Valid UserDTO userDTO){ User user = userDTO.convertToUser(); User saveResultUser = userService.addUser(user); UserDTO result = userDTO.convertFor(saveResultUser); return result; } 我们需要将验证结果传给前端，这种异常应该转化为一个api异常(带有错误码的异常)。 @PostMapping public UserDTO addUser(@Valid UserDTO userDTO, BindingResult bindingResult){ checkDTOParams(bindingResult); User user = userDTO.convertToUser(); User saveResultUser = userService.addUser(user); UserDTO result = userDTO.convertFor(saveResultUser); return result; } private void checkDTOParams(BindingResult bindingResult){ if(bindingResult.hasErrors()){ //throw new 带验证码的验证错误异常 } } BindingResult是Spring MVC验证DTO后的一个结果集，可以参考spring 官方文档 检查参数后，可以抛出一个“带验证码的验证错误异常”，具体异常设计可以参考如何优雅的设计java异常 ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:8:2","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"拥抱lombok 上边的DTO代码，已经让我看的很累了，我相信读者也是一样，看到那么多的Getter和Setter方法，太烦躁了，那时候有什么方法可以简化这些呢。 请拥抱lombok,它会帮助我们解决一些让我们很烦躁的问题 ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:9:0","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"去掉Setter和Getter 其实这个标题，我不太想说，因为网上太多，但是因为很多人告诉我，他们根本就不知道lombok的存在，所以为了让读者更好的学习，我愿意写这样一个例子： @Setter @Getter public class UserDTO { @NotNull private String username; @NotNull private int age; public User convertToUser(){ UserDTOConvert userDTOConvert = new UserDTOConvert(); User convert = userDTOConvert.convert(this); return convert; } public UserDTO convertFor(User user){ UserDTOConvert userDTOConvert = new UserDTOConvert(); UserDTO convert = userDTOConvert.reverse().convert(user); return convert; } private static class UserDTOConvert extends Converter\u003cUserDTO, User\u003e { @Override protected User doForward(UserDTO userDTO) { User user = new User(); BeanUtils.copyProperties(userDTO,user); return user; } @Override protected UserDTO doBackward(User user) { throw new AssertionError(\"不支持逆向转化方法!\"); } } } 看到了吧，烦人的Getter和Setter方法已经去掉了。 但是上边的例子根本不足以体现lombok的强大。我希望写一些网上很难查到，或者很少人进行说明的lombok的使用以及在使用时程序语义上的说明。 比如:@Data,@AllArgsConstructor,@NoArgsConstructor..这些我就不进行一一说明了，请大家自行查询资料. ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:9:1","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"bean中的链式风格 什么是链式风格？我来举个例子，看下面这个Student的bean: public class Student { private String name; private int age; public String getName() { return name; } public Student setName(String name) { this.name = name; return this; } public int getAge() { return age; } public Student setAge(int age) { return this; } } 仔细看一下set方法，这样的设置便是chain的style，调用的时候，可以这样使用: Student student = new Student() .setAge(24) .setName(\"zs\"); 相信合理使用这样的链式代码，会更多的程序带来很好的可读性，那看一下如果使用lombok进行改善呢，请使用 @Accessors(chain = true),看如下代码: @Accessors(chain = true) @Setter @Getter public class Student { private String name; private int age; } 这样就完成了一个对于bean来讲很友好的链式操作。 ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:9:2","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"静态构造方法 静态构造方法的语义和简化程度真的高于直接去new一个对象。比如new一个List对象，过去的使用是这样的: List\u003cString\u003e list = new ArrayList\u003c\u003e(); 看一下guava中的创建方式: List\u003cString\u003e list = Lists.newArrayList(); Lists命名是一种约定(俗话说：约定优于配置)，它是指Lists是List这个类的一个工具类，那么使用List的工具类去产生List，这样的语义是不是要比直接new一个子类来的更直接一些呢，答案是肯定的，再比如如果有一个工具类叫做Maps，那你是否想到了创建Map的方法呢： HashMap\u003cString, String\u003e objectObjectHashMap = Maps.newHashMap(); 好了，如果你理解了我说的语义，那么，你已经向成为java程序员更近了一步了。 再回过头来看刚刚的Student，很多时候，我们去写Student这个bean的时候，他会有一些必输字段，比如Student中的name字段，一般处理的方式是将name字段包装成一个构造方法，只有传入name这样的构造方法，才能创建一个Student对象。 接上上边的静态构造方法和必传参数的构造方法，使用lombok将更改成如下写法（@RequiredArgsConstructor 和 @NonNull）: @Accessors(chain = true) @Setter @Getter @RequiredArgsConstructor(staticName = \"ofName\") public class Student { @NonNull private String name; private int age; } 测试代码: Student student = Student.ofName(\"zs\"); 这样构建出的bean语义是否要比直接new一个含参的构造方法(包含 name的构造方法)要好很多。 当然，看过很多源码以后，我想相信将静态构造方法ofName换成of会先的更加简洁: @Accessors(chain = true) @Setter @Getter @RequiredArgsConstructor(staticName = \"of\") public class Student { @NonNull private String name; private int age; } 测试代码: Student student = Student.of(\"zs\"); 当然他仍然是支持链式调用的: Student student = Student.of(\"zs\").setAge(24); 这样来写代码，真的很简洁，并且可读性很强。 ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:9:3","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"使用builder Builder模式我不想再多解释了，读者可以看一下《Head First》(设计模式) 的建造者模式。 今天其实要说的是一种变种的builder模式，那就是构建bean的builder模式，其实主要的思想是带着大家一起看一下lombok给我们带来了什么。 看一下Student这个类的原始builder状态: public class Student { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public static Builder builder(){ return new Builder(); } public static class Builder{ private String name; private int age; public Builder name(String name){ this.name = name; return this; } public Builder age(int age){ this.age = age; return this; } public Student build(){ Student student = new Student(); student.setAge(age); student.setName(name); return student; } } } 调用方式: Student student = Student.builder().name(\"zs\").age(24).build(); 这样的builder代码，让我是在恶心难受，于是我打算用lombok重构这段代码: @Builder public class Student { private String name; private int age; } 调用方式: Student student = Student.builder().name(\"zs\").age(24).build(); ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:9:4","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"代理模式 正如我们所知的，在程序中调用rest接口是一个常见的行为动作，如果你和我一样使用过spring 的RestTemplate,我相信你会我和一样，对他抛出的非http状态码异常深恶痛绝。 所以我们考虑将RestTemplate最为底层包装器进行包装器模式的设计: public abstract class FilterRestTemplate implements RestOperations { protected volatile RestTemplate restTemplate; protected FilterRestTemplate(RestTemplate restTemplate){ this.restTemplate = restTemplate; } //实现RestOperations所有的接口 } 然后再由扩展类对FilterRestTemplate进行包装扩展: public class ExtractRestTemplate extends FilterRestTemplate { private RestTemplate restTemplate; public ExtractRestTemplate(RestTemplate restTemplate) { super(restTemplate); this.restTemplate = restTemplate; } public \u003cT\u003e RestResponseDTO\u003cT\u003e postForEntityWithNoException(String url, Object request, Class\u003cT\u003e responseType, Object... uriVariables) throws RestClientException { RestResponseDTO\u003cT\u003e restResponseDTO = new RestResponseDTO\u003cT\u003e(); ResponseEntity\u003cT\u003e tResponseEntity; try { tResponseEntity = restTemplate.postForEntity(url, request, responseType, uriVariables); restResponseDTO.setData(tResponseEntity.getBody()); restResponseDTO.setMessage(tResponseEntity.getStatusCode().name()); restResponseDTO.setStatusCode(tResponseEntity.getStatusCodeValue()); }catch (Exception e){ restResponseDTO.setStatusCode(RestResponseDTO.UNKNOWN_ERROR); restResponseDTO.setMessage(e.getMessage()); restResponseDTO.setData(null); } return restResponseDTO; } } 包装器ExtractRestTemplate很完美的更改了异常抛出的行为，让程序更具有容错性。在这里我们不考虑ExtractRestTemplate完成的功能，让我们把焦点放在FilterRestTemplate上，“实现RestOperations所有的接口”,这个操作绝对不是一时半会可以写完的，当时在重构之前我几乎写了半个小时,如下: public abstract class FilterRestTemplate implements RestOperations { protected volatile RestTemplate restTemplate; protected FilterRestTemplate(RestTemplate restTemplate) { this.restTemplate = restTemplate; } @Override public \u003cT\u003e T getForObject(String url, Class\u003cT\u003e responseType, Object... uriVariables) throws RestClientException { return restTemplate.getForObject(url,responseType,uriVariables); } @Override public \u003cT\u003e T getForObject(String url, Class\u003cT\u003e responseType, Map\u003cString, ?\u003e uriVariables) throws RestClientException { return restTemplate.getForObject(url,responseType,uriVariables); } @Override public \u003cT\u003e T getForObject(URI url, Class\u003cT\u003e responseType) throws RestClientException { return restTemplate.getForObject(url,responseType); } @Override public \u003cT\u003e ResponseEntity\u003cT\u003e getForEntity(String url, Class\u003cT\u003e responseType, Object... uriVariables) throws RestClientException { return restTemplate.getForEntity(url,responseType,uriVariables); } //其他实现代码略。。。 } 我相信你看了以上代码，你会和我一样觉得恶心反胃，后来我用lombok提供的代理注解优化了我的代码(@Delegate): @AllArgsConstructor public abstract class FilterRestTemplate implements RestOperations { @Delegate protected volatile RestTemplate restTemplate; } 这几行代码完全替代上述那些冗长的代码。 是不是很简洁，做一个拥抱lombok的程序员吧。 重构 ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:9:5","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"需求案例 ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:10:0","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"项目需求 项目开发阶段，有一个关于下单发货的需求：如果今天下午3点前进行下单，那么发货时间是明天，如果今天下午3点后进行下单，那么发货时间是后天，如果被确定的时间是周日，那么在此时间上再加1天为发货时间。 ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:10:1","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"思考与重构 我相信这个需求看似很简单，无论怎么写都可以完成。 很多人可能看到这个需求，就动手开始写Calendar或Date进行计算，从而完成需求。 而我给的建议是，仔细考虑如何写代码，然后再去写，不是说所有的时间操作都用Calendar或Date去解决，一定要看场景。 对于时间的计算我们要考虑joda-time这种类似的成熟时间计算框架来写代码，它会让代码更加简洁和易读。 请读者先考虑这个需求如何用java代码完成，或先写一个你觉得完成这个代码的思路，再来看我下边的代码，这样，你的收获会更多一些: final DateTime DISTRIBUTION_TIME_SPLIT_TIME = new DateTime().withTime(15,0,0,0); private Date calculateDistributionTimeByOrderCreateTime(Date orderCreateTime){ DateTime orderCreateDateTime = new DateTime(orderCreateTime); Date tomorrow = orderCreateDateTime.plusDays(1).toDate(); Date theDayAfterTomorrow = orderCreateDateTime.plusDays(2).toDate(); return orderCreateDateTime.isAfter(DISTRIBUTION_TIME_SPLIT_TIME) ? wrapDistributionTime(theDayAfterTomorrow) : wrapDistributionTime(tomorrow); } private Date wrapDistributionTime(Date distributionTime){ DateTime currentDistributionDateTime = new DateTime(distributionTime); DateTime plusOneDay = currentDistributionDateTime.plusDays(1); boolean isSunday = (DateTimeConstants.SUNDAY == currentDistributionDateTime.getDayOfWeek()); return isSunday ? plusOneDay.toDate() : currentDistributionDateTime.toDate() ; } 读这段代码的时候，你会发现，我将判断和有可能出现的不同结果都当做一个变量，最终做一个三目运算符的方式进行返回，这样的优雅和可读性显而易见，当然这样的代码不是一蹴而就的，我优化了3遍产生的以上代码。读者可根据自己的代码和我写的代码进行对比。 ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:10:2","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"提高方法 如果你做了3年+的程序员，我相信像如上这样的需求，你很轻松就能完成，但是如果你想做一个会写java的程序员，就好好的思考和重构代码吧。 写代码就如同写字一样，同样的字，大家都会写，但是写出来是否好看就不一定了。如果想把程序写好，就要不断的思考和重构，敢于尝试，敢于创新，不要因循守旧，一定要做一个优秀的java程序员。 提高代码水平最好的方法就是有条理的重构！(注意：是有条理的重构) ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:10:3","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"设计模式 设计模式就是工具，而不是提现你是否是高水平程序员的一个指标。 我经常会看到某一个程序员兴奋的大喊，哪个程序哪个点我用到了设计模式，写的多么多么优秀，多么多么好。我仔细去翻阅的时候，却发现有很多是过度设计的。 ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:11:0","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"业务驱动技术 or 技术驱动业务 业务驱动技术 or 技术驱动业务 ？ 其实这是一个一直在争论的话题，但是很多人不这么认为，我觉得就是大家不愿意承认罢了。我来和大家大概分析一下作为一个java程序员，我们应该如何判断自己所处于的位置. 业务驱动技术：如果你所在的项目是一个收益很小或者甚至没有收益的项目，请不要搞其他创新的东西，不要驱动业务要如何如何做，而是要熟知业务现在的痛点是什么？如何才能帮助业务盈利或者让项目更好，更顺利的进行。 技术驱动业务：如果你所在的项目是一个很牛的项目，比如淘宝这类的项目，我可以在满足业务需求的情况下，和业务沟通，使用什么样的技术能更好的帮助业务创造收益，比如说下单的时候要进队列，可能几分钟之后订单状态才能处理完成，但是会让用户有更流畅的体验，赚取更多的访问流量，那么我相信业务愿意被技术驱动，会同意订单的延迟问题，这样便是技术驱动业务。 我相信大部分人还都处于业务驱动技术的方向吧。 所以你既然不能驱动业务，那就请拥抱业务变化吧。 ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:11:1","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"代码设计 一直在做java后端的项目，经常会有一些变动，我相信大家也都遇到过。 比如当我们写一段代码的时候，我们考虑将需求映射成代码的状态模式，突然有一天，状态模式里边又添加了很多行为变化的东西，这时候你就挠头了，你硬生生的将状态模式中添加过多行为和变化。 慢慢的你会发现这些状态模式，其实更像是一簇算法，应该使用策略模式，这时你应该已经晕头转向了。 说了这么多，我的意思是，只要你觉得合理，就请将状态模式改为策略模式吧，所有的模式并不是凭空想象出来的，都是基于重构。 java编程中没有银弹，请拥抱业务变化，一直思考重构，你就有一个更好的代码设计! ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:11:2","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"你真的优秀吗？ 真不好意思，我取了一个这么无聊的标题。 国外流行一种编程方式，叫做结对编程，我相信国内很多公司都没有这么做，我就不在讲述结对编程带来的好处了，其实就是一边code review，一边互相提高的一个过程。既然做不到这个，那如何让自己活在自己的世界中不断提高呢？ “平时开发的时候，做出的代码总认为是正确的，而且写法是完美的。”，我相信这是大部分人的心声，还回到刚刚的问题，如何在自己的世界中不断提高呢？ 答案就是: 多看成熟框架的源码 多回头看自己的代码 勤于重构 你真的优秀吗？ 如果你每周都完成了学习源码，回头看自己代码，然后勤于重构，我认为你就真的很优秀了。 即使也许你只是刚刚入门，但是一直坚持，你就是一个真的会写java代码的程序员了。 技能 ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:12:0","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"UML 不想多讨论UML相关的知识，但是我觉得你如果真的会写java，请先学会表达自己，UML就是你说话的语言，做一名优秀的java程序员，请至少学会这两种UML图： 类图 时序图 ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:13:0","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"clean code 我认为保持代码的简洁和可读性是代码的最基本保证，如果有一天为了程序的效率而降低了这两点，我认为是可以谅解的，除此之外，没有任何理由可以让你任意挥霍你的代码。 读者可以看一下Robert C. Martin出版的《Clean Code》（代码整洁之道） 这本书 可以参考美团文章聊聊clean code 也可以看一下阿里的Java编码规范 无论如何，请保持你的代码的整洁。 ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:14:0","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"linux 基础命令 这点其实和会写java没有关系，但是linux很多时候确实承载运行java的容器，请学好linux的基础命令。 参考鸟哥的《Linux私房菜》 总结 java是一个大体系，今天讨论并未涉及框架和架构相关知识，只是讨论如何写好代码。 本文从写java程序的小方面一直写到大方面，来阐述了如何才能写好java程序，并告诉读者们如何才能提高自身的编码水平。 我希望看到这篇文章的各位都能做一个优秀的java程序员。 ","date":"2021-07-22","objectID":"/2021/can_you_write_java/:15:0","tags":["Java","编程语言","最佳实践"],"title":"细思极恐-你真的会写java吗?","uri":"/2021/can_you_write_java/"},{"categories":["Java"],"content":"这篇文章总结了 Java 基础知识.","date":"2021-06-25","objectID":"/2021/java-basic/","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"[TOC] 一、数据类型 ","date":"2021-06-25","objectID":"/2021/java-basic/:0:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"基本类型 基本类型 大小 最小值 最大值 默认值 包装器类型 boolean - - - false Boolean byte 8 -128 127 (byte)0 Byte char 16 Unicode 0 Unicode 65535 \\u0000 Character short 16 -32768 32767 (short)0 Short int 32 -231 231-1 0 Integer、BigInteger long 64 -263 263-1 0L Long float 32 IEEE754 IEEE754 0.0f Float、BigDecimal double 64 IEEE754 IEEE754 0.0d, 0.0 Double boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但通过读写 byte 数组来实现的。 char （采用UTF-16LE编码Unicode字符）中只能放 UTF-16 编码下只占 2 字节的那些字符 Primitive Data Types The Java® Virtual Machine Specification ","date":"2021-06-25","objectID":"/2021/java-basic/:1:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"包装类型 基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。包装类型是不可变对象！ Integer x = 2; // 装箱 调用了 Integer.valueOf(2) int y = x; // 拆箱 调用了 X.intValue() ++x; // 先拆箱，在自增，最后在装箱，注意：操作完成后，x将引用另外一个Integer对象 Autoboxing and Unboxing ","date":"2021-06-25","objectID":"/2021/java-basic/:2:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"缓存池 new Integer(123) 与 Integer.valueOf(123) 的区别在于： new Integer(123) 每次都会新建一个对象； Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。 Integer x = new Integer(123); Integer y = new Integer(123); System.out.println(x == y); // false Integer z = Integer.valueOf(123); Integer k = Integer.valueOf(123); System.out.println(z == k); // true valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。 public static Integer valueOf(int i) { if (i \u003e= IntegerCache.low \u0026\u0026 i \u003c= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } 在 Java 8 中，Integer 缓存池的大小默认为 -128~127。 static final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) { try { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { // If the property cannot be parsed into an int, ignore it. } } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k \u003c cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high \u003e= 127; } 编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。 Integer m = 123; Integer n = 123; System.out.println(m == n); // true 基本类型对应的缓冲池如下： boolean values true and false all byte values short values between -128 and 127 int values between -128 and 127 char in the range \\u0000 to \\u007F 在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。 在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=\u003csize\u003e 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。 StackOverflow : Differences between new Integer(123), Integer.valueOf(123) and just 123 ","date":"2021-06-25","objectID":"/2021/java-basic/:3:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"参数传递 方法类型：签名由 Java 的参数是以值传递的形式传入方法中，而不是引用传递。 以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。 public class Dog { String name; Dog(String name) { this.name = name; } String getName() { return this.name; } void setName(String name) { this.name = name; } String getObjectAddress() { return super.toString(); } } 在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。 class PassByValueExample { public static void main(String[] args) { Dog dog = new Dog(\"A\"); func(dog); System.out.println(dog.getName()); // B } private static void func(Dog dog) { dog.setName(\"B\"); } } 但是在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象，在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响。 public class PassByValueExample { public static void main(String[] args) { Dog dog = new Dog(\"A\"); System.out.println(dog.getObjectAddress()); // Dog@4554617c func(dog); System.out.println(dog.getObjectAddress()); // Dog@4554617c System.out.println(dog.getName()); // A } private static void func(Dog dog) { System.out.println(dog.getObjectAddress()); // Dog@4554617c dog = new Dog(\"B\"); System.out.println(dog.getObjectAddress()); // Dog@74a14482 System.out.println(dog.getName()); // B } } StackOverflow: Is Java “pass-by-reference” or “pass-by-value”? ","date":"2021-06-25","objectID":"/2021/java-basic/:4:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"类型转换 强制类型转换：显式向下转型 (SubClass)baseRef，其正确性由Run-Time Type Identification`机制保证 自动类型转换：Java 仅支持隐式向上转型，不能隐式执行向下转型，因为这会使得精度降低。但有一个例外： TODO: 自动包装 TODO: toString()自动类型转换 因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型。 short s1 = 1; //! s1 = s1 + 1; 但是使用 += 或者 ++ 运算符会执行隐式类型转换。 s1 += 1; s1++; 上面的语句相当于将 s1 + 1 的计算结果进行了显式向下转型： s1 = (short) (s1 + 1); StackOverflow : Why don’t Java’s +=, -=, *=, /= compound assignment operators require casting? ","date":"2021-06-25","objectID":"/2021/java-basic/:5:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"类对象初始化 new 分配对象空间，并执行成员变量默认初始化 执行成员变量显式初始化 调用构造方法：调用构造器之前，所有数据成员按定义顺序依次初始化 返回对象地址 二、String ","date":"2021-06-25","objectID":"/2021/java-basic/:6:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"字符集与编码 字符集 编号(code point) 编码(encoding) 用途 BOM 拉丁字母 ASCII ASCII 简体中文 GB2312 GB2312 所有字符 Unicode UTF-8 变长，兼容ASCII、适合存储、传输 EFBBBF(统一用大端BE) 使用代理区表示Unicode字符 0x10FFFF UTF-16 **定长，**省空间、用于内存表示 FEFF(BE)、FFFE(LE) 使用4字节表示Unicode字符 Unicode UTF-32 直观表示所有Unicode，但浪费空间 \\uFEFF 字符、Unicode、UTF-8、UTF-16、UTF-32相互编码和解码。一次可连续输入64个字符；编码也是连续输入，但需注意UTF-16/32的字节顺序标记（BOM），如果没有提供BOM，默认以大尾序解码。 Unicode 是容纳世界所有文字符号的国际标准编码，使用四个字节为每个字符编码。 UTF 是英文 Unicode Transformation Format 的缩写，意为把 Unicode 字符转换为某种格式。UTF 系列编码方案（UTF-8、UTF-16、UTF-32）均是由 Unicode 编码方案衍变而来，以适应不同的数据存储或传递，它们都可以完全表示 Unicode 标准中的所有字符。目前，这些衍变方案中 UTF-8 被广泛使用，而 UTF-16 和 UTF-32 则很少被使用。 UTF-8 使用一至四个字节为每个字符编码，其中大部分汉字采用三个字节编码，少量不常用汉字采用四个字节编码。因为 UTF-8 是可变长度的编码方式，相对于 Unicode 编码可以减少存储占用的空间，所以被广泛使用。 UTF-16 使用二或四个字节为每个字符编码，其中大部分汉字采用两个字节编码，少量不常用汉字采用四个字节编码。UTF-16 编码有大尾序和小尾序之别，即 UTF-16BE 和 UTF-16LE，在编码前会放置一个 U+FEFF 或 U+FFFE（UTF-16BE 以 FEFF 代表，UTF-16LE 以 FFFE 代表），其中 U+FEFF 字符在 Unicode 中代表的意义是 ZERO WIDTH NO-BREAK SPACE，顾名思义，它是个没有宽度也没有断字的空白。 UTF-32 使用四个字节为每个字符编码，使得 UTF-32 占用空间通常会是其它编码的二到四倍。UTF-32 与 UTF-16 一样有大尾序和小尾序之别，编码前会放置 U+0000FEFF 或 U+FFFE0000 以区分。 字符集与编码（四）——Unicode ","date":"2021-06-25","objectID":"/2021/java-basic/:7:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"概览 String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承） 在 Java 8 中，String 内部使用 char 数组存储数据。 public final class String implements java.io.Serializable, Comparable\u003cString\u003e, CharSequence { /** The value is used for character storage. */ private final char value[]; } 在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。 public final class String implements java.io.Serializable, Comparable\u003cString\u003e, CharSequence { /** The value is used for character storage. */ private final byte[] value; /** The identifier of the encoding used to encode the bytes in {@code value}. */ private final byte coder; } value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。 ","date":"2021-06-25","objectID":"/2021/java-basic/:8:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"不可变的好处 1. 可以缓存 hash 值 因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。 2. String Pool 的需要 如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。 3. 安全性 String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。 4. 线程安全 String 不可变性天生具备线程安全，可以在多个线程中安全地使用。 Program Creek : Why String is immutable in Java? ","date":"2021-06-25","objectID":"/2021/java-basic/:9:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"String, StringBuffer and StringBuilder 1. 可变性 String 不可变 StringBuffer 和 StringBuilder 可变 2. 线程安全 String 不可变，因此是线程安全的 StringBuilder 线程不安全，但是效率高 StringBuffer 是线程安全的，内部使用 synchronized 进行同步 StackOverflow : String, StringBuffer, and StringBuilder ","date":"2021-06-25","objectID":"/2021/java-basic/:10:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"String Pool 字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。 当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。 下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得同一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。 String s1 = new String(\"aaa\"); String s2 = new String(\"aaa\"); System.out.println(s1 == s2); // false String s3 = s1.intern(); String s4 = s1.intern(); System.out.println(s3 == s4); // true 如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。 String s5 = \"bbb\"; String s6 = \"bbb\"; System.out.println(s5 == s6); // true 在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。 StackOverflow : What is String interning? 深入解析 String#intern ","date":"2021-06-25","objectID":"/2021/java-basic/:11:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"new String(“abc”) 使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。 “abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量； 而使用 new 的方式会在堆中创建一个字符串对象。 创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。 public class NewStringTest { public static void main(String[] args) { String s = new String(\"abc\"); } } 使用 javap -verbose 进行反编译，得到以下内容： // ... Constant pool: // ... #2 = Class #18 // java/lang/String #3 = String #19 // abc // ... #18 = Utf8 java/lang/String #19 = Utf8 abc // ... public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=3, locals=2, args_size=1 0: new #2 // class java/lang/String 3: dup 4: ldc #3 // String abc 6: invokespecial #4 // Method java/lang/String.\"\u003cinit\u003e\":(Ljava/lang/String;)V 9: astore_1 // ... 在 Constant Pool 中，#19 存储这字符串字面量 “abc”，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。 以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。 public String(String original) { this.value = original.value; this.hash = original.hash; } ","date":"2021-06-25","objectID":"/2021/java-basic/:12:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"格式化输出 System.out.printf(\"格式说明符\", var1, var2...); System.out.format(\"格式说明符\", var1, var2...); 格式说明符 %[arguementIndex$][flags][width][.precision]conversion arguementIndex$：参数占位符 flags：对齐控制，默认右对齐，-为左对齐 width：控制域最小尺寸 .precision：控制域最大尺寸，不能用于整型 conversion：格式转换 conversion meaning d 十进制整数 x 十六进制整数 h 十六进制hash值 % % f 十进制浮点数 e 科学技术浮点数 b boolean值 c Unicode字符 s 字符串 ","date":"2021-06-25","objectID":"/2021/java-basic/:13:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"正则表达式 三、时间相关类 long now = System.currentTimeMillis(); Date date = new Date(now); // 精确到毫秒 DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\") String daytime = df.format(date); Date date = df.parse(\"2007-10-7 20:15:30\") Calendar calendar = new GregorianCalendar(); 四、关键字 ","date":"2021-06-25","objectID":"/2021/java-basic/:14:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"switch 从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。 String s = \"a\"; switch (s) { case \"a\": System.out.println(\"aaa\"); break; case \"b\": System.out.println(\"bbb\"); break; } switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么还是用 if 比较合适。 // long x = 111; // switch (x) { // Incompatible types. Found: 'long', required: 'char, byte, short, int, Character, Byte, Short, Integer, String, or an enum' // case 111: // System.out.println(111); // break; // case 222: // System.out.println(222); // break; // } StackOverflow : Why can’t your switch statement data type be long, Java? ","date":"2021-06-25","objectID":"/2021/java-basic/:15:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"final 1. 数据 声明数据为常量，可以是编译时常量，也可以是在运行时（用一个方法赋值、构造方法内赋值）被初始化后不能被改变的常量。 对于基本类型，final 使数值不变； 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。 final int x = 1; // x = 2; // cannot assign value to final variable 'x' final A y = new A(); y.a = 1; 2. 方法 声明方法不能被子类重写，只能继承。 private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。 3. 类 声明类不允许被继承。 ","date":"2021-06-25","objectID":"/2021/java-basic/:16:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"static 1. 静态变量 静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。 public class A { private int x; // 实例变量 private static int y; // 静态变量 public static void main(String[] args) { // int x = A.x; // Non-static field 'x' cannot be referenced from a static context A a = new A(); int x = a.x; int y = A.y; } } 2. 静态方法 静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。 public abstract class A { public static void func1(){ } // Illegal combination of modifiers: 'abstract' and 'static' // public abstract static void func2(); } 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因此这两个关键字与具体对象关联；也不能直接调用非静态方法。 public class A { private static int x; private int y; public static void func1(){ int a = x; // int b = y; // Non-static field 'y' cannot be referenced from a static context // int b = this.y; // 'A.this' cannot be referenced from a static context } } 3. 静态语句块 静态语句块在类初始化时运行一次。 public class A { static { System.out.println(\"123\"); } public static void main(String[] args) { A a1 = new A(); A a2 = new A(); } } 123 4. 静态内部类 非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。 public class OuterClass { class InnerClass { } static class StaticInnerClass { } public static void main(String[] args) { // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context OuterClass outerClass = new OuterClass(); InnerClass innerClass = outerClass.new InnerClass(); StaticInnerClass staticInnerClass = new StaticInnerClass(); } } 静态内部类不能访问外部类的非静态的变量和方法。 5. 静态导包 在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。 import static com.xxx.ClassName.* 6. 初始化顺序 静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。 public static String staticField = \"静态变量\"; static { System.out.println(\"静态语句块\"); } public String field = \"实例变量\"; { System.out.println(\"普通语句块\"); } // 可在此语句块内进行实例初始化 最后才是构造函数的初始化。 public InitialOrderTest() { System.out.println(\"构造函数\"); } 存在继承的情况下，初始化顺序为： 父类（静态变量、静态语句块）//初次访问类中静态成员加载类，同时进行static初始 子类（静态变量、静态语句块） // 静态块在类加载时执行 父类（实例变量、普通语句块）//创建类实例时 父类（构造函数） 子类（实例变量、普通语句块） 子类（构造函数） 五、Object 通用方法 ","date":"2021-06-25","objectID":"/2021/java-basic/:17:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"概览 public native int hashCode() public boolean equals(Object obj) protected native Object clone() throws CloneNotSupportedException public String toString() public final native Class\u003c?\u003e getClass() protected void finalize() throws Throwable {} public final native void notify() public final native void notifyAll() public final native void wait(long timeout) throws InterruptedException public final void wait(long timeout, int nanos) throws InterruptedException public final void wait() throws InterruptedException ","date":"2021-06-25","objectID":"/2021/java-basic/:18:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"equals() 1. 等价关系 两个对象具有等价关系，需要满足以下五个条件： Ⅰ 自反性 x.equals(x); // true Ⅱ 对称性 x.equals(y) == y.equals(x); // true Ⅲ 传递性 if (x.equals(y) \u0026\u0026 y.equals(z)) x.equals(z); // true; Ⅳ 一致性 多次调用 equals() 方法结果不变 x.equals(y) == x.equals(y); // true Ⅴ 与 null 的比较 对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false x.equals(null); // false; 2. 等价与相等 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。 Integer x = new Integer(1); Integer y = new Integer(1); System.out.println(x.equals(y)); // true System.out.println(x == y); // false 3. 实现 检查是否为同一个对象的引用，如果是直接返回 true； 检查是否是同一个类型，如果不是，直接返回 false； 将 Object 对象进行转型； 判断每个关键域是否相等。 public class EqualExample { private int x; private int y; private int z; public EqualExample(int x, int y, int z) { this.x = x; this.y = y; this.z = z; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; EqualExample that = (EqualExample) o; if (x != that.x) return false; if (y != that.y) return false; return z == that.z; } } ","date":"2021-06-25","objectID":"/2021/java-basic/:19:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"hashCode() hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。 在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。 HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法。 下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象。但是 EqualExample 没有实现 hashCode() 方法，因此这两个对象的哈希值是不同的，最终导致集合添加了两个等价的对象。 EqualExample e1 = new EqualExample(1, 1, 1); EqualExample e2 = new EqualExample(1, 1, 1); System.out.println(e1.equals(e2)); // true HashSet\u003cEqualExample\u003e set = new HashSet\u003c\u003e(); set.add(e1); set.add(e2); System.out.println(set.size()); // 2 理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。 R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：31*x == (x\u003c\u003c5)-x，编译器会自动进行这个优化。 @Override public int hashCode() { int result = 17; result = 31 * result + x; result = 31 * result + y; result = 31 * result + z; return result; } ","date":"2021-06-25","objectID":"/2021/java-basic/:20:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"toString() 支持任何类向string的转换 默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。 public class ToStringExample { private int number; public ToStringExample(int number) { this.number = number; } } ToStringExample example = new ToStringExample(123); System.out.println(example.toString()); ToStringExample@4554617c ","date":"2021-06-25","objectID":"/2021/java-basic/:21:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"clone() 1. cloneable clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。 public class CloneExample { private int a; private int b; } CloneExample e1 = new CloneExample(); // CloneExample e2 = e1.clone(); // 'clone()' has protected access in 'java.lang.Object' 重写 clone() 得到以下实现： public class CloneExample { private int a; private int b; @Override public CloneExample clone() throws CloneNotSupportedException { return (CloneExample)super.clone(); } } CloneExample e1 = new CloneExample(); try { CloneExample e2 = e1.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } java.lang.CloneNotSupportedException: CloneExample 以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。 应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。 public class CloneExample implements Cloneable { private int a; private int b; @Override public Object clone() throws CloneNotSupportedException { return super.clone(); } } 2. 浅拷贝 拷贝对象和原始对象的引用类型引用同一个对象。 public class ShallowCloneExample implements Cloneable { private int[] arr; public ShallowCloneExample() { arr = new int[10]; for (int i = 0; i \u003c arr.length; i++) { arr[i] = i; } } public void set(int index, int value) { arr[index] = value; } public int get(int index) { return arr[index]; } @Override protected ShallowCloneExample clone() throws CloneNotSupportedException { return (ShallowCloneExample) super.clone(); } } ShallowCloneExample e1 = new ShallowCloneExample(); ShallowCloneExample e2 = null; try { e2 = e1.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } e1.set(2, 222); System.out.println(e2.get(2)); // 222 3. 深拷贝 拷贝对象和原始对象的引用类型引用不同对象。 public class DeepCloneExample implements Cloneable { private int[] arr; public DeepCloneExample() { arr = new int[10]; for (int i = 0; i \u003c arr.length; i++) { arr[i] = i; } } public void set(int index, int value) { arr[index] = value; } public int get(int index) { return arr[index]; } @Override protected DeepCloneExample clone() throws CloneNotSupportedException { DeepCloneExample result = (DeepCloneExample) super.clone(); result.arr = new int[arr.length]; for (int i = 0; i \u003c arr.length; i++) { result.arr[i] = arr[i]; } return result; } } DeepCloneExample e1 = new DeepCloneExample(); DeepCloneExample e2 = null; try { e2 = e1.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } e1.set(2, 222); System.out.println(e2.get(2)); // 2 4. clone() 的替代方案 使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。 public class CloneConstructorExample { private int[] arr; public CloneConstructorExample() { arr = new int[10]; for (int i = 0; i \u003c arr.length; i++) { arr[i] = i; } } public CloneConstructorExample(CloneConstructorExample original) { arr = new int[original.arr.length]; for (int i = 0; i \u003c original.arr.length; i++) { arr[i] = original.arr[i]; } } public void set(int index, int value) { arr[index] = value; } public int get(int index) { return arr[index]; } } CloneConstructorExample e1 = new CloneConstructorExample(); CloneConstructorExample e2 = new CloneConstructorExample(e1); e1.set(2, 222); System.out.println(e2.get(2)); // 2 ","date":"2021-06-25","objectID":"/2021/java-basic/:22:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"finalize() finalize、垃圾回收机制、System.gc()、引用计数、stop-and-copy停止复制、复制式回收器、自适应分代的、标记-清扫（mark-and-sweep）、即时编译器（JIT） 六、面向对象 ","date":"2021-06-25","objectID":"/2021/java-basic/:23:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"OOP概念 数据抽象与封装： 创建新的数据类型：将数据与方法包装进类 用权限控制隐藏具体实现：接口与实现分离、防止用户误改内部机制 复用类： 继承：is a，复用接口，通过覆盖方法表达行为差异 组合：has a，使用对象，用字段表达状态上的变化 优先使用组合 多态： 动态绑定，消除类型耦合关系，使程序可拓展 分离做什么与怎么做，将接口与实现分离 改善代码结构和可读性 绑定：将一个方法调用与方法主体关联（符号引用–\u003e直接引用） 前期/静态绑定：程序执行前由编译器或链接程序实现绑定，静态方法、私有方法（子类不可见，隐含final语义，因此不可被继承，就不是虚方法），实例构造方法（不可被继承）；此类方法编译器可知，在编译期完成绑定（符号引用–\u003e直接引用），运行期不可改变。 后期/动态绑定：运行时根据对象类型进行绑定，Java中对域的访问都是在编译器进行静态绑定的，除了final、static方法外均采用动态绑定，我们称运行期间将符号引用转化为直接引用的方法为虚方法。 设计模式 ","date":"2021-06-25","objectID":"/2021/java-basic/:24:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"类文件组织 编译单元：ClassName.java 每个.java文件内最多能有一个public类，且该类必须与文件同名 文件内其他类在包内可见，仅用来为主public类提供支持 .java文件经编译生成对应的.class文件 类库单元：package 包名须使用小写字母 包（类库）实质是一组类文件 package须出现在文件起始处 import可使包内名称在包外可用 默认包：若.java文件未明确设定包名称，则其默认隶属与其目录的默认包中 文件组织 创建一个独一无二的包名：domain.package 查找隐藏于目录结构中的某处的类：将包名分解为机器上的一个目录，并将属于该包的所有.class文件置于该目录下 ","date":"2021-06-25","objectID":"/2021/java-basic/:25:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"访问权限 Java 中有四种访问权限：private、default（默认包访问权限package）、protected 以及 public。 可以对类或类中的成员（字段和方法）加上访问修饰符。 类可见表示其它类可以用这个类创建实例对象。 成员可见表示其它类可以用这个类的实例对象访问到该成员； protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。 设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。 如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例去代替，也就是确保满足里氏替换原则。 字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。 public class AccessExample { public String id; } 可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。 public class AccessExample { private int id; public String getId() { return id + \"\"; } public void setId(String id) { this.id = Integer.valueOf(id); } } 但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。 public class AccessWithInnerClassExample { private class InnerClass { int x; } private InnerClass innerClass; public AccessWithInnerClassExample() { innerClass = new InnerClass(); } public int getValue() { return innerClass.x; // 直接访问 } } ","date":"2021-06-25","objectID":"/2021/java-basic/:26:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"抽象类与接口 ","date":"2021-06-25","objectID":"/2021/java-basic/:27:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"1. 抽象类 抽象类和抽象方法都使用 abstract 关键字进行声明 抽象方法仅有声明，不能有方法体，抽象方法必须在非抽象的子类中覆盖（具体实现） 抽象类中可以没有任何抽象方法，若一个类中包含抽象方法，那么这个类必须声明为抽象类 抽象类不能被实例化，只能被继承 public abstract class AbstractClassExample { protected int x; private int y; public abstract void func1(); public void func2() { System.out.println(\"func2\"); } } public class AbstractExtendClassExample extends AbstractClassExample { @Override public void func1() { System.out.println(\"func1\"); } } // AbstractClassExample ac1 = new AbstractClassExample(); // 'AbstractClassExample' is abstract; cannot be instantiated AbstractClassExample ac2 = new AbstractExtendClassExample(); ac2.func1(); ","date":"2021-06-25","objectID":"/2021/java-basic/:27:1","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"2. 接口 接口本身默认为包权限，可声明为public 接口的成员（方法、域/字段）默认都是 public 的，并且不允许定义为 private 或者 protected 接口的域/字段默认都是 static 和 final 的 接口的内部类默认是 static（嵌套类）的，且是可继承的 接口的方法默认是abstract的，不能有方法体 用default声明的接口方法可以有默认方法体 接口是抽象类的延伸，从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了（在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。） // 成员变量只能是 public static final 的 public static final String name = \"张三\"; String name = \"张三\"; // 方法总是 public abstract 的 public abstract List\u003cString\u003e getUserNames(Long companyId); List\u003cString\u003e getUserNames(Long companyId); public interface InterfaceExample { void func1(); default void func2(){ System.out.println(\"func2\"); } int x = 123; // int y; // Variable 'y' might not have been initialized public int z = 0; // Modifier 'public' is redundant for interface fields // private int k = 0; // Modifier 'private' not allowed here // protected int l = 0; // Modifier 'protected' not allowed here // private void fun3(); // Modifier 'private' not allowed here } public class InterfaceImplementExample implements InterfaceExample { @Override public void func1() { System.out.println(\"func1\"); } } // InterfaceExample ie1 = new InterfaceExample(); // 'InterfaceExample' is abstract; cannot be instantiated InterfaceExample ie2 = new InterfaceImplementExample(); ie2.func1(); System.out.println(InterfaceExample.x); ","date":"2021-06-25","objectID":"/2021/java-basic/:27:2","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"3. 比较 从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。 ","date":"2021-06-25","objectID":"/2021/java-basic/:27:3","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"4. 使用选择 使用接口： 需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法； 需要使用多重继承。 使用抽象类： 需要在几个相关的类中共享代码。 需要能控制继承来的成员的访问权限，而不是都为 public。 需要继承非静态和非常量字段。 在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。 Abstract Methods and Classes 深入理解 abstract class 和 interface When to Use Abstract Class and Interface ","date":"2021-06-25","objectID":"/2021/java-basic/:27:4","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"内部类（nested class） 嵌套类（静态内部类）、嵌套接口、多重继承、闭包、回调 （外部类$内部类.class） ","date":"2021-06-25","objectID":"/2021/java-basic/:28:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"非静态内部类（成员内部类） 非静态内部类必须寄存在一个外部类对象里。因此，如果有一个非静态内部类对象那么一定存在对应的外部类对象。非静态内部类对象单独属于外部类的某个对象。 编译为 Outer$Inner.class 非静态内部类 的 非静态实例 隐式包含对外部类的引用this$0，使用Outer.this访问外部类对象 public class Main { public static void main(String[] args) { Outer outer = new Outer(\"Nested\"); // 实例化一个Outer Outer.Inner inner = outer.new Inner(); // 实例化一个Inner inner.hello(); } } class Outer { private String name; Outer(String name) { this.name = name; } class Inner { void hello() { name += \", call from inner!\"; // 可访问外部类私有域 System.out.println(\"Hello, \" + Outer.this.name); // 可访问外部类的实例 } } } 非静态内部类可以直接访问外部类的成员，但是外部类不能直接访问非静态内部类成员。 非静态内部类不能有静态方法、静态属性和静态初始化块。 外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例。 ","date":"2021-06-25","objectID":"/2021/java-basic/:28:1","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"静态内部类 用static修饰的内部类和Inner Class有很大的不同，它不再依附于Outer的实例，而是一个完全独立的类，因此无法引用Outer.this，但它可以访问Outer的private静态字段和静态方法。如果把StaticNested移到Outer之外，就失去了访问private的权限。编译为 Outer$Inner.class public class Main { public static void main(String[] args) { Outer.StaticNested sn = new Outer.StaticNested(); sn.hello(); } } class Outer { private static String NAME = \"OUTER\"; private String name; Outer(String name) { this.name = name; } static class StaticNested { void hello() { System.out.println(\"Hello, \" + Outer.NAME); } } } ","date":"2021-06-25","objectID":"/2021/java-basic/:28:2","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"匿名内部类 ​ 适合那种只需要使用一次的类，匿名类被编译为Outer$1.class public class Main { public static void main(String[] args) { Outer outer = new Outer(\"Nested\"); outer.asyncHello(); } } class Outer { private String name; Outer(String name) { this.name = name; } void asyncHello() { Runnable r = new Runnable() { @Override public void run() { System.out.println(\"Hello, \" + Outer.this.name); // 匿名内部类引用外部类实例 } }; new Thread(r).start(); } } ","date":"2021-06-25","objectID":"/2021/java-basic/:28:3","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"局部内部类 ​ 定义在方法内部的，作用域只限于本方法，称为局部内部类。编译为 Outer$1Inner.class package com.qf.demo1; /* * 局部内部类 * 1.相当于方法里的局部变量，只能在方法中使用 * */ public class Test { public static void main(String[] args) { Test();//局部内部类是随着方法的调用而被执行 } public static void Test() { int a =4; //局部内部类 //inner 局部内部类 不能添加访问权限修饰符 class Inner { private int age; private String name; public void eat() { System.out.print(\"吃\"); } } //局部内部类只能在声明这个内部类的方法中创建对象 Inner inner = new Inner(); inner.eat(); System.out.println(inner.name); } } ","date":"2021-06-25","objectID":"/2021/java-basic/:28:4","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"super 访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。 访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。 public class SuperExample { protected int x; protected int y; public SuperExample(int x, int y) { this.x = x; this.y = y; } public void func() { System.out.println(\"SuperExample.func()\"); } } public class SuperExtendExample extends SuperExample { private int z; public SuperExtendExample(int x, int y, int z) { super(x, y); this.z = z; } @Override public void func() { super.func(); System.out.println(\"SuperExtendExample.func()\"); } } SuperExample e = new SuperExtendExample(1, 2, 3); e.func(); SuperExample.func() SuperExtendExample.func() Using the Keyword super ","date":"2021-06-25","objectID":"/2021/java-basic/:29:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"重写与重载 1. 重写（Override） 存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。 为了满足里式替换原则，重写需要符合下面的三个要点： “==”： 方法名、形参列表相同（方法签名相同）。 “≤”：返回值类型和声明异常类型，子类小于等于父类。 “≥”： 访问权限，子类大于等于父类。 使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。 下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中： 子类方法访问权限为 public，大于父类的 protected。 子类的返回类型为 ArrayList，是父类返回类型 List 的子类。 子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。 子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。 class SuperClass { protected List\u003cInteger\u003e func() throws Throwable { return new ArrayList\u003c\u003e(); } } class SubClass extends SuperClass { @Override public ArrayList\u003cInteger\u003e func() throws Exception { return new ArrayList\u003c\u003e(); } } 在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为： this.func(this) super.func(this) this.func(super) super.func(super) /* A | B | C | D */ class A { public void show(A obj) { System.out.println(\"A.show(A)\"); } public void show(C obj) { System.out.println(\"A.show(C)\"); } } class B extends A { @Override public void show(A obj) { System.out.println(\"B.show(A)\"); } } class C extends B { } class D extends C { } public static void main(String[] args) { A a = new A(); B b = new B(); C c = new C(); D d = new D(); // 在 A 中存在 show(A obj)，直接调用 a.show(a); // A.show(A) // 在 A 中不存在 show(B obj)，将 B 转型成其父类 A a.show(b); // A.show(A) // 在 B 中存在从 A 继承来的 show(C obj)，直接调用 b.show(c); // A.show(C) // 在 B 中不存在 show(D obj)，但是存在从 A 继承来的 show(C obj)，将 D 转型成其父类 C b.show(d); // A.show(C) // 引用的还是 B 对象，所以 ba 和 b 的调用结果一样 A ba = new B(); ba.show(c); // A.show(C) ba.show(d); // A.show(C) } 2. 重载（Overload） 存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。应该注意的是，返回值不同，其它都相同不算是重载。 七、反射 ","date":"2021-06-25","objectID":"/2021/java-basic/:30:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"Class对象 运行时类型信息的表示 每个类都有一个Class对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。 类加载相当于 Class 对象的加载，类在第一次使用时（程序创建第一个对类的静态成员的引用时）才动态加载到 JVM 中。也可以使用 Class.forName(\"com.mysql.jdbc.Driver\") 这种方式来控制类的加载，该方法会返回一个 Class 对象。 加载：类加载器查找字节码（.class文件），读取并创建一个Class对象（注意：访问编译期常量、类字面常量不会引起类链接，即惰性初始化） 链接：验证字节码，为静态域分配存储空间 初始化：若有父类，对其初始化；执行静态初始化器与静态初始化块 ","date":"2021-06-25","objectID":"/2021/java-basic/:31:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"RTTI与反射 运行时识别类和对象信息： RTTI（Run-Time Type Identification）：编译器编译时打开和检查.class文件，编译时已经知道所有的类型，可以查询引用所指对象的确切类型 (type)：传统的类型转换，由RTTI确保正确性，若错误，抛出ClassCastException异常 Class对象：包含对象的类型信息 instanceof：查看对象是否是某特定类的实例 反射：.class文件编译时不可获取，运行时打开和检查.calss文件，可以提供运行时的类信息。 Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类： Field ：class.getField()，可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段； Method ：class.getMethod()，可以使用 invoke() 方法调用与 Method 对象关联的方法； Constructor ：class.Constructor()，可以用 Constructor 的 newInstance() 创建新的对象。 反射的优点： 可扩展性：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。 类浏览器和可视化开发环境：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。 调试器和测试工具： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。 反射的缺点： 尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。 性能开销：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。 安全限制：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。 内部暴露：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。 Trail: The Reflection API 深入解析 Java 反射（1）- 基础 八、异常 Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： Error 和 Exception。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种： 受检异常 ：需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复； 非受检异常 ：是程序运行时错误（RuntimeException），例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。 Java 入门之异常处理 Java 异常的面试问题及答案 -Part 1 九、泛型 泛型（generics）字面意义为泛化的类型，即参数化类型。 ","date":"2021-06-25","objectID":"/2021/java-basic/:32:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"泛型类 泛型的类型参数只能是类类型，不能是简单类型。 不能对确切的泛型类型使用instanceof操作。 //此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型 //在实例化泛型类时，必须指定T的具体类型 public class Box\u003cT\u003e { // key这个成员变量的类型为T，T的类型在实例化时指定 private T key; public void set(T key) { this.key = key; } public T get() { return key; } } ","date":"2021-06-25","objectID":"/2021/java-basic/:33:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"泛型接口 泛型接口与泛型类的定义及使用基本相同，常被用在各种类的生成器中 //定义一个泛型接口 public interface Generator\u003cT\u003e { public T next(); } /**当实现泛型接口的类，未传入泛型实参时，在声明类的时候需将泛型的声明也一起加到类中： * 即：class FruitGenerator\u003cT\u003e implements Generator\u003cT\u003e{ * 如果不声明泛型，如：class FruitGenerator implements Generator\u003cT\u003e，编译器会报错：\"Unknown class\" */ class FruitGenerator\u003cT\u003e implements Generator\u003cT\u003e{ @Override public T next() { return null; } } /**当实现泛型接口的类，传入泛型实参时，则所有使用泛型的地方都要替换成传入的实参类型 * 即：Generator\u003cT\u003e，public T next();中的的T都要替换成传入的String类型。 */ public class FruitGenerator implements Generator\u003cString\u003e { private String[] fruits = new String[]{\"Apple\", \"Banana\", \"Pear\"}; @Override public String next() { Random rand = new Random(); return fruits[rand.nextInt(3)]; } } ","date":"2021-06-25","objectID":"/2021/java-basic/:34:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"泛型方法 定义泛型方法的规则如下： 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的 ）。 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。 泛型方法体的声明和其他方法一样。注意类型参数 只能代表引用型类型，不能是原始类型 （像 int,double,char 的等）。 public class GenericMethodTest { // 泛型方法 printArray public static \u003c E \u003e void printArray( E[] inputArray ){ // 输出数组元素 for ( E element : inputArray ){ System.out.printf( \"%s \", element ); } System.out.println(); } /*泛型方法与可变参数 * args实质是T[]类型的数组 */ public \u003cT\u003e void printMsg( T... args){ for(T t : args){ System.out.println(\"泛型测试\" + \"t is \" + t.getClass() + \"\\t\" + t); } } public static void main( String args[] ){ // 创建不同类型数组： Integer, Double 和 Character Integer[] intArray = { 1, 2, 3, 4, 5 }; Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 }; Character[] charArray = { 'H', 'E', 'L', 'L', 'O'}; System.out.println( \"整型数组元素为:\" ); printArray( intArray ); // 传递一个整型 System.out.println( \"\\n双精度型数组元素为:\" ); printArray( doubleArray ); // 传递一个双精度型 System.out.println( \"\\n字符型数组元素为:\" ); printArray( charArray ); // 传递一个字符型数组 printMsg(\"111\",222,\"aaaa\",\"2323.4\",55.55); // 实际传入java.io.Serializable类型数组 } } ","date":"2021-06-25","objectID":"/2021/java-basic/:35:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"泛型数组 在java中不能创建一个确切的泛型类型的数组，使用通配符创建泛型数组是可以的。 // 不能创建一个确切的泛型类型的数组 // List\u003cString\u003e[] ls = new ArrayList\u003cString\u003e[10]; // 使用通配符创建泛型数组是可以的 List\u003c?\u003e[] ls = new ArrayList\u003c?\u003e[10]; // raw use 也是可以的 List\u003cString\u003e[] ls = new ArrayList[10]; // 这种有类型检查遗漏风险问题 List[] ls = new ArrayList[10]; public class GenericTest { public static void main(String[] args) throws Exception { List\u003cString\u003e[] ls = new List[2]; List\u003cObject\u003e l = new LinkedList\u003c\u003e(); l.add(new Object()); // ls[0] = l; // 类型检查不通过 // 绕过了类型检查 Object[] obgList = (Object[])ls; obgList[0] = l; obgList[1] = new ArrayList\u003cInteger\u003e(); /* * class [Ljava.util.List; * 泛型测试t is class java.util.LinkedList [java.lang.Object@2a84aee7] * 泛型测试t is class java.util.ArrayList [] */ printMsg(obgList); } } ","date":"2021-06-25","objectID":"/2021/java-basic/:36:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"泛型通配符与上下界 类型通配符一般是使用 ? 代替具体的类型参数。例如 List\u003c?\u003e 在逻辑上是 List\u003cString\u003e，List\u003cInteger\u003e 等所有 List\u003c具体类型实参\u003e 的父类。 类型通配符上限通过形如 List\u003c? extends Number\u003e 来定义，如此定义就是通配符泛型值接受 Number 及其下层子类类型。 类型通配符下限通过形如 List\u003c? super Number\u003e 来定义，表示类型只能接受 Number 及其父类类型，如 Objec 类型的实例。 public class GenericsAndCovariance { public static void main(String[] args) { /* 限定上界的不允许写入 */ List\u003c? extends Fruit\u003e flist = new ArrayList\u003cApple\u003e(); // Compile Error: can’t add any type of object: // flist.add(new Apple()); // flist.add(new Fruit()); // flist.add(new Object()); flist.add(null); // Legal but uninteresting // We know that it returns at least Fruit: Fruit f = flist.get(0); } /* 限定下界的可写入下届及其子类 */ static void writeTo(List\u003c? super Apple\u003e apples) { apples.add(new Apple()); apples.add(new Jonathan()); // apples.add(new Fruit()); // Error } } ","date":"2021-06-25","objectID":"/2021/java-basic/:37:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"泛型擦除 **泛型只在编译阶段有效，泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。***在泛型代码内部，无法获得任何有关泛型参数类型的信息* 通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。 public class ErasedTypeEquivalence { public static void main(String[] args) { Class c1 = new ArrayList\u003cString\u003e().getClass(); Class c2 = new ArrayList\u003cInteger\u003e().getClass(); System.out.println(c1 == c2); // true } } // 在泛型代码内部，无法获得任何有关泛型参数类型的信息，运行时参数T实质为Object类型 // 利用java的RTTI运行时类型信息与反射，可以解决这个问题，不过使用时要显式传入Class参数 public class HasF { public void f() { System.out.println(\"HasF.f()\"); } } class Manipulator\u003cT\u003e { private T obj; public Manipulator(T x) { obj = x; } // Error: cannot find symbol: method f(): public void manipulate() { obj.f(); } } public class Manipulation { public static void main(String[] args) { HasF hf = new HasF(); Manipulator\u003cHasF\u003e manipulator = new Manipulator\u003cHasF\u003e(hf); manipulator.manipulate(); } } Java 泛型详解 10 道 Java 泛型面试题 十、注解 Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。 注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。编译器对其生成与不带注解的代码相同的虚拟机指令。 ","date":"2021-06-25","objectID":"/2021/java-basic/:38:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"用法 编译检查：@SuppressWarnings, @Deprecated与@Override 在反射中使用Annotation：测试、日志、事务等代码自动生成 附属文件自动生成：@Documented ","date":"2021-06-25","objectID":"/2021/java-basic/:39:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"语法 声明用法：包、类、接口 | 方法、成员、局部变量、参数变量、类型参数 类型用法java 惯用法：注意注解位置应由注解接口指定 private @NonNull String text; // Annotates the type use @Id private String userId; // Annotates the variable public User getUser(@NonNull String userId) // userId 被注解了，同时其参数类型为 @NonNull String 每一个注解必须通过一个注解接口进行定义 @Retention(RetentionPolicy.RUNTIME) public @interface BugReport { // 继承自java.lang.annotation.Annotation enum Status {UNCONFIRMED, CONFIRMED, FIXED, NOTABUG}; boolean showStopper() default false; String assignedTo() default \"[none]\"; Class\u003c?\u003e testCase() default Void.class; Status status() default Status.UNCONFIRMED; // 参数由编译器计算而来，默认值应为编译期常量，且不为null Reference ref() default @Reference(); // an annotation type，注意不要引入循环依赖 String[] reportedBy(); // 数组赋值需要加{}: `reportBy={\"charles\", \"Cheung\"}` } 标记注解 @Test 适用于注解无元素或者都有默认值 单值注解 @SingleValue(\"name\") 适用于仅有一个元素的注解 ","date":"2021-06-25","objectID":"/2021/java-basic/:40:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"元注解 元注解 作用 Target 描述注解的使用范围（即被修饰的注解可以用在什么地方） Reteniton 描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时） Documented 描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。 Inherited 使被它修饰的注解具有继承性（如果某个类使用了被@Inherited修饰的注解，则其子类将自动具有该注解） Repeatable 允许在同一申明类型（类，属性，或方法）前多次使用同一个类型注解 public enum ElementType { TYPE, // 类、接口、枚举类 FIELD, // 成员变量（包括：枚举常量） METHOD, // 成员方法 PARAMETER, // 方法参数 CONSTRUCTOR, // 构造方法 LOCAL_VARIABLE, // 局部变量 ANNOTATION_TYPE, // 注解类 PACKAGE, // 可用于修饰：包 TYPE_PARAMETER, // 变量注解：类型参数，JDK 1.8 新增，表示该注解能写在类型参数的声明语句中 TYPE_USE // 类型注解：使用类型的任何地方，JDK 1.8 新增 } public enum RetentionPolicy { SOURCE, // 源文件保留,如 @Override 和 @SuppressWarnings，不包含在class文件中 CLASS, // 编译期保留，默认值，包含在class文件中，但不加载进虚拟机 RUNTIME // 运行期保留，可通过反射去获取注解信息 } ","date":"2021-06-25","objectID":"/2021/java-basic/:41:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"标准注解 注解 作用域 作用 Deprecated 方法 对已过时的方法发出警告 SuppressedWarnings 阻止特定类型的警告信息 Override 方法 检查方法是否真正覆盖超类的方法 Generated 所有 代码生成使用，用以区分与程序员编写代码 PostConstruct 方法 控制对象生命周期：对象构建后调用 PreDestroy 方法 控制对象生命周期：对象销毁前调用 Resource 类、接口、方法、域 资源注入 ","date":"2021-06-25","objectID":"/2021/java-basic/:42:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"字节码工程 ","date":"2021-06-25","objectID":"/2021/java-basic/:43:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"asm 修改类文件 ","date":"2021-06-25","objectID":"/2021/java-basic/:43:1","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"加载时修改字节码 注解 Annotation 实现原理与自定义注解例子 Java Annotation认知(包括框架图、详细介绍、示例说明) 十一、Lambda表达式与Stream API 编程思想： 面向过程编程 面向对象编程 函数式编程 面向切面编程 面向消息编程 ","date":"2021-06-25","objectID":"/2021/java-basic/:43:2","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"1. Lambda 表达式 Lambda 表达式是一个匿名函数，即没有函数名的函数，可以表示闭包。Lambda 表达式简化了匿名内部类的形式，但其实内部的实现原理却不相同：匿名内部类在编译之后会创建一个新的匿名内部类出来，而 Lambda 被编译器封装为主类的一个private static 方法，然后调用 JVM invokedynamic指令实现的，并不会产生新类。其使用有两个条件： 必须有相应的函数接口（函数接口是指内部只有一个抽象方法的接口，通常使用@FunctionalInterface标注） 类型推断机制：在上下文信息足够的情况下，编译器可以推断出参数表的类型，而不需要显式指名 ","date":"2021-06-25","objectID":"/2021/java-basic/:44:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"2. Lambda 写法 Runnable run = () -\u003e System.out.println(\"Hello World\");// 1 无参数 ActionListener listener = event -\u003e System.out.println(\"button clicked\");// 2 单参数 BinaryOperator\u003cLong\u003e add = (Long x, Long y) -\u003e x + y;// 3 多参数 BinaryOperator\u003cLong\u003e addImplicit = (x, y) -\u003e x + y;// 4 多参数的类型推断 Runnable multiLine = () -\u003e {// 5 代码块 System.out.print(\"Hello\"); System.out.println(\" Hoolee\"); }; // 与匿名内部类对比 new Thread(new Runnable(){// 接口名 @Override public void run(){// 方法名 System.out.println(\"Thread run()\"); } }).start(); new Thread( () -\u003e System.out.println(\"Thread run()\") // 省略接口名和方法名 ).start(); ","date":"2021-06-25","objectID":"/2021/java-basic/:45:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"3. 方法引用与构造器引用 方法引用可以将一个方法赋给一个变量或者作为参数传递给另外一个方法，甚至将方法作为一个函数式接口的实例。 诸如String::length的语法形式叫做方法引用（method references），这种语法用来替代某些特定形式Lambda表达式。如果Lambda表达式的全部内容就是调用一个已有的方法，那么可以用方法引用来替代Lambda表达式。方法引用可以细分为四类： 方法引用类别 举例 引用静态方法 Integer::sum 引用某个对象的方法 list::add 引用某个类的方法 String::length 引用构造方法 HashMap::new // 引用方法的参数个数、类型，返回值类型要和函数式接口中的方法声明一一对应才行 Comparator\u003cInteger\u003e comparator = Integer::compare; int result = comparator.compare(100,10); IntBinaryOperator intBinaryOperator = Integer::compare; int result = intBinaryOperator.applyAsInt(10,100); // 构造器引用 Integer::new ","date":"2021-06-25","objectID":"/2021/java-basic/:46:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"4. Stream BaseStream接口包括四个继承接口，其中IntStream, LongStream, DoubleStream对应三种基本类型（int, long, double，注意不是包装类型），Stream对应所有剩余类型的stream视图。为不同数据类型设置不同stream接口，可以 提高性能 增加特定接口函数。 大部分情况下stream是容器调用Collection.stream()方法得到的，但stream和collections有以下不同： 无存储。stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。 为函数式编程而生。对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。 惰式执行。stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。 可消费性。stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。 ","date":"2021-06-25","objectID":"/2021/java-basic/:47:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"5. Stream API 对stream的操作分为两类，可以通过方法的返回值进行区分，即返回值为stream的大都是中间操作，否则是结束操作。 中间操作（intermediate operations）：总是会惰式执行，调用中间操作只会生成一个标记了该操作的新stream，仅此而已。 结束操作（terminal operations）：会触发实际计算，计算发生时会把所有中间操作积攒的操作以pipeline的方式执行，这样可以减少迭代次数。计算完成之后stream就会失效。 操作类型 接口方法 中间操作 concat() distinct() filter() flatMap() limit() map() peek() skip() sorted() parallel() sequential() unordered() 结束操作 allMatch() anyMatch() collect() count() findAny() findFirst() forEach() forEachOrdered() max() min() noneMatch() reduce() toArray() 规约操作（reduction operation）又被称作折叠操作（fold），是通过某个连接动作将所有元素汇总成一个汇总结果的过程。元素求和、求最大值或最小值、求出元素总个数、将所有元素转换成一个列表或集合，都属于规约操作。Stream类库有两个通用的规约操作reduce()和collect() ","date":"2021-06-25","objectID":"/2021/java-basic/:48:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"6. Reduce详解 reduce操作可以实现从一组元素中生成一个值，sum()、max()、min()、count()等都是reduce操作，将他们单独设为函数只是因为常用。reduce()的方法定义有三种重写形式： Optional\u003cT\u003e reduce(BinaryOperator\u003cT\u003e accumulator) T reduce(T identity, BinaryOperator\u003cT\u003e accumulator) \u003cU\u003e U reduce(U identity, BiFunction\u003cU,? super T,U\u003e accumulator, BinaryOperator\u003cU\u003e combiner) 虽然函数定义越来越长，但语义不曾改变，多的参数只是为了指明初始值（参数identity），或者是指定并行执行时多个部分结果的合并方式（参数combiner）。reduce()最常用的场景就是从一堆值中生成一个值。用这么复杂的函数去求一个最大或最小值，你是不是觉得设计者有病。其实不然，因为“大”和“小”或者“求和”有时会有不同的语义。 // 求单词长度之和 Stream\u003cString\u003e stream = Stream.of(\"I\", \"love\", \"you\", \"too\"); Integer lengthSum = stream.reduce(0,　// 初始值　// (1) (sum, str) -\u003e sum+str.length(), // 累加器 // (2) (a, b) -\u003e a+b);　// 部分和拼接器，并行执行时才会用到 // (3) // int lengthSum = stream.mapToInt(str -\u003e str.length()).sum(); System.out.println(lengthSum); ","date":"2021-06-25","objectID":"/2021/java-basic/:49:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"7. Collect详解 collect()是Stream接口方法中最灵活的一个，如果某个功能在Stream接口中没找到，十有八九可以通过collect()方法实现，其方法签名为： \u003cR\u003e R collect(Supplier\u003cR\u003e supplier, BiConsumer\u003cR,? super T\u003e accumulator, BiConsumer\u003cR,R\u003e combiner) \u003cR,A\u003e R collect(Collector\u003c? super T,A,R\u003e collector) 收集器（Collector）是为Stream.collect()方法量身打造的工具接口（类）。考虑一下将一个Stream转换成一个容器（或者Map）需要做哪些工作？我们至少需要： 目标容器是什么？是*ArrayList*还是*HashSet*，或者是个*TreeMap*。 新元素如何添加到容器中？是List.add()还是Map.put()。 如果并行的进行规约，还需要告诉collect()如何将多个部分结果合并成一个。 通常情况下我们不需要手动指定collect()的三个参数，而是调用collect(Collector\u003c? super T,A,R\u003e collector)方法，并且参数中的Collector对象大都是直接通过Collectors工具类获得。实际上传入的收集器的行为决定了collect()的行为。 Stream\u003cString\u003e stream = Stream.of(\"I\", \"love\", \"you\", \"too\"); List\u003cString\u003e list = stream.collect(ArrayList::new, ArrayList::add, ArrayList::addAll); // (0) // 使用Collector List\u003cString\u003e list = stream.collect(Collectors.toList()); // (1) Set\u003cString\u003e set = stream.collect(Collectors.toSet()); // (2) // 使用toCollection()指定规约容器的类型 ArrayList\u003cString\u003e arrayList = stream.collect(Collectors.toCollection(ArrayList::new));// (3) HashSet\u003cString\u003e hashSet = stream.collect(Collectors.toCollection(HashSet::new));// (4) Stream背后依赖于某种数据源，数据源可以是数组、容器等，但不能是Map。反过来从*Stream*生成*Map*是可以的，但我们要想清楚*Map*的*key*和*value*分别代表什么，根本原因是我们要想清楚要干什么。通常在三种情况下collect()的结果会是*Map*： 使用Collectors.toMap()生成的收集器，用户需要指定如何生成Map的key和value。 使用Collectors.partitioningBy()生成的收集器，对元素进行二分区操作时用到。 使用Collectors.groupingBy()生成的收集器，对元素做group操作时用到。 // 使用toMap()统计学生GPA Map\u003cStudent, Double\u003e studentToGPA = students.stream().collect(Collectors.toMap(Function.identity(),// 如何生成key student -\u003e computeGPA(student)));// 如何生成value // Partition students into passing and failing Map\u003cBoolean, List\u003cStudent\u003e\u003e passingFailing = students.stream() .collect(Collectors.partitioningBy(s -\u003e s.getGrade() \u003e= PASS_THRESHOLD)); // Group employees by department Map\u003cDepartment, List\u003cEmployee\u003e\u003e byDept = employees.stream() .collect(Collectors.groupingBy(Employee::getDepartment)); // 根据部门分组 // 使用下游收集器统计每个部门的人数 Map\u003cDepartment, Integer\u003e totalByDept = employees.stream() .collect(Collectors.groupingBy(Employee::getDepartment, Collectors.counting()));// 下游收集器，count聚合 // 按照部门对员工分布组，并只保留员工的名字 Map\u003cDepartment, List\u003cString\u003e\u003e byDept = employees.stream() .collect(Collectors.groupingBy(Employee::getDepartment, Collectors.mapping(Employee::getName,// 下游收集器 Collectors.toList())));// 更下游的收集器 字符串拼接时使用Collectors.joining()生成的收集器，从此告别for循环。Collectors.joining()方法有三种重写形式，分别对应三种不同的拼接方式。 // 使用Collectors.joining()拼接字符串 Stream\u003cString\u003e stream = Stream.of(\"I\", \"love\", \"you\"); //String joined = stream.collect(Collectors.joining()); // \"Iloveyou\" //String joined = stream.collect(Collectors.joining(\",\")); // \"I,love,you\" String joined = stream.collect(Collectors.joining(\",\", \"{\", \"}\")); // \"{I,love,you}\" String joined = stream.collect(StringBuilder::new, (s1, s2) -\u003e { // \"{I,love,you}\" if (StringUtils.isEmpty(s1)) { s1.append(s2); } else { s1.append(',').append(s2); } }, StringBuilder::append).append('}').insert(0, '{').toString(); ","date":"2021-06-25","objectID":"/2021/java-basic/:50:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"8. Stream Pipelines原理 直观的讲，为每一次函数调用都执一次迭代一定能够实现功能，但效率上肯定是无法接受的： 迭代次数多。迭代次数跟函数调用的次数相等。 频繁产生中间结果。每次函数调用都产生一次中间结果，存储开销无法接受。 Stream类库的实现着使用流水线（Pipeline）的方式巧妙的避免了多次迭代，其基本思想是在一次迭代中尽可能多的执行用户指定的操作，具体来讲其将操作分为两类：中间操作和结束操作 中间操作只是一种标记，在遇到结束操作之前只是把中间操作记录了下来。中间操作可以分为无状态的(Stateless)和有状态的(Stateful)： 无状态中间操作是指元素的处理不受前面元素的影响。 有状态的中间操作必须等到所有元素处理之后才知道最终结果，比如排序是有状态操作，在读取所有元素之前并不能确定排序结果； 结束操作会触发实际计算，可以分为短路操作和非短路操作： 短路操作是指不用处理全部元素就可以返回结果，比如找到第一个满足条件的元素。 非短路操作必须处理完所有元素才能返回结果。 Stream操作 分类 中间操作(Intermediate operations) 无状态(Stateless) unordered() filter() map() mapToInt() mapToLong() mapToDouble() flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek() 有状态(Stateful) distinct() sorted() sorted() limit() skip() 结束操作(Terminal operations) 短路操作(short-circuiting) anyMatch() allMatch() noneMatch() findFirst() findAny() 非短路操作 forEach() forEachOrdered() toArray() reduce() collect() max() min() count() 之所以要进行如此精细的划分，是因为底层对每一种情况的处理方式不同，具体来讲，有以下几个问题： 用户的操作如何记录？ 操作如何叠加？ 叠加之后的操作如何执行？ 执行后的结果（如果有）在哪里？ ","date":"2021-06-25","objectID":"/2021/java-basic/:51:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"1. 操作如何记录？ 注意这里使用的是“操作(operation)”一词，指的是“Stream中间操作”的操作，很多Stream操作会需要一个回调函数（Lambda表达式），因此一个完整的操作是**\u003c*数据源，操作，回调函数*\u003e**构成的三元组。Stream中使用Stage的概念来描述一个完整的操作，并用某种实例化后的*PipelineHelper*来代表Stage，将具有先后顺序的各个Stage连到一起，就构成了整个流水线。跟Stream相关类和接口的继承关系图示。 还有IntPipeline, LongPipeline, DoublePipeline没在图中画出，这三个类专门为三种基本类型（不是包装类型）而定制的，跟ReferencePipeline是并列关系。 图中Head用于表示第一个Stage，即调用诸如Collection.stream()方法产生的Stage，很显然这个Stage里不包含任何操作；StatelessOp和StatefulOp分别表示无状态和有状态的Stage，对应于无状态和有状态的中间操作。Stream流水线组织结构示意图如下： 图中通过Collection.stream()方法得到Head也就是stage0，紧接着调用一系列的中间操作，不断产生新的Stream。这些Stream对象以双向链表的形式组织在一起，构成整个流水线，由于每个Stage都记录了前一个Stage和本次的操作以及回调函数，依靠这种结构就能建立起对数据源的所有操作。这就是Stream记录操作的方式。 ","date":"2021-06-25","objectID":"/2021/java-basic/:51:1","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"2. 操作如何叠加？ 以上只是解决了操作记录的问题，要想让流水线起到应有的作用我们需要一种将所有操作叠加到一起的方案。你可能会觉得这很简单，只需要从流水线的head开始依次执行每一步的操作（包括回调函数）就行了。这听起来似乎是可行的，但是你忽略了前面的Stage并不知道后面Stage到底执行了哪种操作，以及回调函数是哪种形式。换句话说，只有当前Stage本身才知道该如何执行自己包含的动作。这就需要有某种协议来协调相邻Stage之间的调用关系。 这种协议由Sink接口完成，Sink接口包含的方法如下表所示： 方法名 作用 void begin(long size) 开始遍历元素之前调用该方法，通知Sink做好准备。 void end() 所有元素遍历完成之后调用，通知Sink没有更多的元素了。 boolean cancellationRequested() 是否可以结束操作，可以让短路操作尽早结束。 void accept(T t) 遍历元素时调用，接受一个待处理元素，并对元素进行处理。Stage把自己包含的操作和回调方法封装到该方法里，前一个Stage只需要调用当前Stage.accept(T t)方法就行了。 有了上面的协议，相邻Stage之间调用就很方便了，每个Stage都会将自己的操作封装到一个Sink里，前一个Stage只需调用后一个Stage的accept()方法即可，并不需要知道其内部是如何处理的。Sink的四个接口方法常常相互协作，共同完成计算任务。实际上Stream API内部实现的的本质，就是如何重载Sink的这四个接口方法。 对于有状态的操作，Sink的begin()和end()方法也是必须实现的。比如Stream.sorted()是一个有状态的中间操作，其对应的Sink.begin()方法可能创建一个存放结果的容器，而accept()方法负责将元素添加到该容器，最后end()负责对容器进行排序。 对于短路操作，Sink.cancellationRequested()也是必须实现的，比如Stream.findFirst()是短路操作，只要找到一个元素，cancellationRequested()就应该返回true，以便调用者尽快结束查找。 有了Sink对操作的包装，Stage之间的调用问题就解决了，执行时只需要从流水线的head开始对数据源依次调用每个Stage对应的Sink.{begin(), accept(), cancellationRequested(), end()}方法就可以了。一种可能的Sink.accept()方法流程是这样的： void accept(U u){ 1. 使用当前Sink包装的回调函数处理u 2. 将处理结果传递给流水线下游的Sink } Sink接口的其他几个方法也是按照这种[处理-\u003e转发]的模型实现。下面我们结合具体例子看看Stream的中间操作是如何将自身的操作包装成Sink以及Sink是如何将处理结果转发给下一个Sink的。先看Stream.map()方法： // Stream.map()，调用该方法将产生一个新的Stream public final \u003cR\u003e Stream\u003cR\u003e map(Function\u003c? super P_OUT, ? extends R\u003e mapper) { ... return new StatelessOp\u003cP_OUT, R\u003e(this, StreamShape.REFERENCE, StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) { @Override /*opWripSink()方法返回由回调函数包装而成Sink*/ Sink\u003cP_OUT\u003e opWrapSink(int flags, Sink\u003cR\u003e downstream) { return new Sink.ChainedReference\u003cP_OUT, R\u003e(downstream) { @Override public void accept(P_OUT u) { R r = mapper.apply(u);// 1. 使用当前Sink包装的回调函数mapper处理u downstream.accept(r);// 2. 将处理结果传递给流水线下游的Sink } }; } }; } 上述代码看似复杂，其实逻辑很简单，就是将回调函数mapper包装到一个Sink当中。由于Stream.map()是一个无状态的中间操作，所以map()方法返回了一个StatelessOp内部类对象（一个新的Stream），调用这个新Stream的opWripSink()方法将得到一个包装了当前回调函数的Sink。 再来看一个复杂一点的例子。Stream.sorted()方法将对Stream中的元素进行排序，显然这是一个有状态的中间操作，因为读取所有元素之前是没法得到最终顺序的。抛开模板代码直接进入问题本质，sorted()方法是如何将操作封装成Sink的呢？sorted()一种可能封装的Sink代码如下： // Stream.sort()方法用到的Sink实现 class RefSortingSink\u003cT\u003e extends AbstractRefSortingSink\u003cT\u003e { private ArrayList\u003cT\u003e list;// 存放用于排序的元素 RefSortingSink(Sink\u003c? super T\u003e downstream, Comparator\u003c? super T\u003e comparator) { super(downstream, comparator); } @Override public void begin(long size) { ... // 创建一个存放排序元素的列表 list = (size \u003e= 0) ? new ArrayList\u003cT\u003e((int) size) : new ArrayList\u003cT\u003e(); } @Override public void end() { list.sort(comparator);// 只有元素全部接收之后才能开始排序 downstream.begin(list.size()); if (!cancellationWasRequested) {// 下游Sink不包含短路操作 list.forEach(downstream::accept);// 2. 将处理结果传递给流水线下游的Sink } else {// 下游Sink包含短路操作 for (T t : list) {// 每次都调用cancellationRequested()询问是否可以结束处理。 if (downstream.cancellationRequested()) break; downstream.accept(t);// 2. 将处理结果传递给流水线下游的Sink } } downstream.end(); list = null; } @Override public void accept(T t) { list.add(t);// 1. 使用当前Sink包装动作处理t，只是简单的将元素添加到中间列表当中 } } 上述代码完美的展现了Sink的四个接口方法是如何协同工作的： 首先beging()方法告诉Sink参与排序的元素个数，方便确定中间结果容器的的大小； 之后通过accept()方法将元素添加到中间结果当中，最终执行时调用者会不断调用该方法，直到遍历所有元素； 最后end()方法告诉Sink所有元素遍历完毕，启动排序步骤，排序完成后将结果传递给下游的Sink； 如果下游的Sink是短路操作，将结果传递给下游时不断询问下游cancellationRequested()是否可以结束处理。 ","date":"2021-06-25","objectID":"/2021/java-basic/:51:2","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"3. 叠加之后的操作如何执行？ Sink完美封装了Stream每一步操作，并给出了[处理-\u003e转发]的模式来叠加操作。这一连串的齿轮已经咬合，就差最后一步拨动齿轮启动执行。是什么启动这一连串的操作呢？也许你已经想到了启动的原始动力就是结束操作(Terminal Operation)，一旦调用某个结束操作，就会触发整个流水线的执行。 结束操作之后不能再有别的操作，所以结束操作不会创建新的流水线阶段(Stage)，直观的说就是流水线的链表不会在往后延伸了。结束操作会创建一个包装了自己操作的Sink，这也是流水线中最后一个Sink，这个Sink只需要处理数据而不需要将结果传递给下游的Sink（因为没有下游）。对于Sink的[处理-\u003e转发]模型，结束操作的Sink就是调用链的出口。 我们再来考察一下上游的Sink是如何找到下游Sink的。一种可选的方案是在PipelineHelper中设置一个Sink字段，在流水线中找到下游Stage并访问Sink字段即可。但Stream类库的设计者没有这么做，而是设置了一个Sink AbstractPipeline.opWrapSink(int flags, Sink downstream)方法来得到Sink，该方法的作用是返回一个新的包含了当前Stage代表的操作以及能够将结果传递给downstream的Sink对象。为什么要产生一个新对象而不是返回一个Sink字段？这是因为使用opWrapSink()可以将当前操作与下游Sink（上文中的downstream参数）结合成新Sink。试想只要从流水线的最后一个Stage开始，不断调用上一个Stage的opWrapSink()方法直到最开始（不包括stage0，因为stage0代表数据源，不包含操作），就可以得到一个代表了流水线上所有操作的Sink，用代码表示就是这样： // AbstractPipeline.wrapSink() // 从下游向上游不断包装Sink。如果最初传入的sink代表结束操作， // 函数返回时就可以得到一个代表了流水线上所有操作的Sink。 final \u003cP_IN\u003e Sink\u003cP_IN\u003e wrapSink(Sink\u003cE_OUT\u003e sink) { ... for (AbstractPipeline p=AbstractPipeline.this; p.depth \u003e 0; p=p.previousStage) { sink = p.opWrapSink(p.previousStage.combinedFlags, sink); } return (Sink\u003cP_IN\u003e) sink; } 现在流水线上从开始到结束的所有的操作都被包装到了一个Sink里，执行这个Sink就相当于执行整个流水线，执行Sink的代码如下： // AbstractPipeline.copyInto(), 对spliterator代表的数据执行wrappedSink代表的操作。 final \u003cP_IN\u003e void copyInto(Sink\u003cP_IN\u003e wrappedSink, Spliterator\u003cP_IN\u003e spliterator) { ... if (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) { wrappedSink.begin(spliterator.getExactSizeIfKnown());// 通知开始遍历 spliterator.forEachRemaining(wrappedSink);// 迭代 wrappedSink.end();// 通知遍历结束 } ... } 上述代码首先调用wrappedSink.begin()方法告诉Sink数据即将到来，然后调用spliterator.forEachRemaining()方法对数据进行迭代（Spliterator是容器的一种迭代器，[参阅](https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/3-Lambda and Collections.md#spliterator)），最后调用wrappedSink.end()方法通知Sink数据处理结束。逻辑如此清晰。 ","date":"2021-06-25","objectID":"/2021/java-basic/:51:3","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"4. 执行后的结果在哪里？ 最后一个问题是流水线上所有操作都执行后，用户所需要的结果（如果有）在哪里？首先要说明的是不是所有的Stream结束操作都需要返回结果，有些操作只是为了使用其副作用(Side-effects)，比如使用Stream.forEach()方法将结果打印出来就是常见的使用副作用的场景（事实上，除了打印之外其他场景都应避免使用副作用），对于真正需要返回结果的结束操作结果存在哪里呢？ 特别说明：副作用不应该被滥用，也许你会觉得在Stream.forEach()里进行元素收集是个不错的选择，就像下面代码中那样，但遗憾的是这样使用的正确性和效率都无法保证，因为Stream可能会并行执行。大多数使用副作用的地方都可以使用归约操作更安全和有效的完成。 // 错误的收集方式 ArrayList\u003cString\u003e results = new ArrayList\u003c\u003e(); stream.filter(s -\u003e pattern.matcher(s).matches()) .forEach(s -\u003e results.add(s)); // Unnecessary use of side-effects! // 正确的收集方式 List\u003cString\u003eresults = stream.filter(s -\u003e pattern.matcher(s).matches()) .collect(Collectors.toList()); // No side-effects! 回到流水线执行结果的问题上来，需要返回结果的流水线结果存在哪里呢？这要分不同的情况讨论，下表给出了各种有返回结果的Stream结束操作。 返回类型 对应的结束操作 boolean anyMatch() allMatch() noneMatch() Optional findFirst() findAny() 归约结果 reduce() collect() 数组 toArray() 对于表中返回boolean或者Optional的操作（Optional是存放一个值的容器）的操作，由于返回一个值，只需要在对应的Sink中记录这个值，等到执行结束时返回就可以了。 对于归约操作，最终结果放在用户调用时指定的容器中（容器类型通过[收集器](https://objcoding.com/2019/03/04/lambda/5-Streams API(II).md#收集器)指定）。collect(), reduce(), max(), min()都是归约操作，虽然max()和min()也是返回一个Optional，但事实上底层是通过调用[reduce()](https://objcoding.com/2019/03/04/lambda/5-Streams API(II).md#多面手reduce)方法实现的。 对于返回是数组的情况，毫无疑问的结果会放在数组当中。这么说当然是对的，但在最终返回数组之前，结果其实是存储在一种叫做Node的数据结构中的。Node是一种多叉树结构，元素存储在树的叶子当中，并且一个叶子节点可以存放多个元素。这样做是为了并行执行方便。关于Node的具体结构，我们会在下一节探究Stream如何并行执行时给出详细说明。 本文详细介绍了Stream流水线的组织方式和执行过程，学习本文将有助于理解原理并写出正确的Stream代码，同时打消你对Stream API效率方面的顾虑。如你所见，Stream API实现如此巧妙，即使我们使用外部迭代手动编写等价代码，也未必更加高效。 ","date":"2021-06-25","objectID":"/2021/java-basic/:51:4","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"9. parallelStream Fork/Join 框架的核心是采用分治法的思想，将一个大任务拆分为若干互不依赖的子任务，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务。同时，为了最大限度地提高并行处理能力，采用了工作窃取算法来运行任务，也就是说当某个线程处理完自己工作队列中的任务后，尝试当其他线程的工作队列中窃取一个任务来执行，直到所有任务处理完毕。所以为了减少线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。 使用parallelStream的几个好处： 代码优雅，可以使用lambda表达式，原本几句代码现在一句可以搞定； 运用多核特性(forkAndJoin)并行处理，大幅提高效率。 关于并行流和多线程的性能测试可以看一下下面的几篇博客： 并行流适用场景-CPU密集型 提交订单性能优化系列之006-普通的Thread多线程改为Java8的parallelStream并发流 然而，任何事物都不是完美的，并行流也不例外，其中最明显的就是使用(parallel)Stream极其不便于代码的跟踪调试，此外并行流带来的不确定性也使得我们对它的使用变得格外谨慎。我们得去了解更多的并行流的相关知识来保证自己能够正确的使用这把双刃剑。 parallelStream使用时需要注意的点： 适用CPU密集型的计算任务，不适用于IO密集型，特别的，对于CPU负载很大的情况也不适用。 不要在多线程中使用parallelStream，原因同上类似，大家都抢着CPU是没有提升效果，反而还会加大线程切换开销。 确保每条处理无状态且没有关联 使用并行流的时候是无法保证元素的顺序的 十三、特性 ","date":"2021-06-25","objectID":"/2021/java-basic/:52:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"Java 各版本的新特性 New highlights in Java SE 8 Lambda Expressions Pipelines and Streams Date and Time API Default Methods Type Annotations Nashhorn JavaScript Engine Concurrent Accumulators Parallel operations PermGen Error Removed New highlights in Java SE 7 Strings in Switch Statement Type Inference for Generic Instance Creation Multiple Exception Handling Support for Dynamic Languages Try with Resources Java nio Package Binary Literals, Underscore in literals Diamond Syntax Difference between Java 1.8 and Java 1.7? Java 8 特性 ","date":"2021-06-25","objectID":"/2021/java-basic/:53:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"Java 与 C++ 的区别 Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。 Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。 Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。 Java 支持自动垃圾回收，而 C++ 需要手动回收。 Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。 Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。 Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。 What are the main differences between Java and C++? ","date":"2021-06-25","objectID":"/2021/java-basic/:54:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Java"],"content":"JRE or JDK JRE：Java Runtime Environment，java运行环境的简称，为java的运行提供了所需的环境。主要包括了JVM的标准实现和一些java基本类库。 JDK：Java Development Kit，java开发工具包，提供了java的开发及运行环境。JDK是java开发的核心，集成了JRE以及一些其他的工具，比如编译 java 源码的编译器 javac等。 因此可以这样认为：JDK\u003eJRE\u003eJVM，JRE支持了java程序的运行，而JDK则同时支持了java程序的开发。 参考资料 Eckel B. Java 编程思想[M]. 机械工业出版社, 2002. Bloch J. Effective java[M]. Addison-Wesley Professional, 2017. ","date":"2021-06-25","objectID":"/2021/java-basic/:55:0","tags":["Java","编程语言"],"title":"Java 基础","uri":"/2021/java-basic/"},{"categories":["Markdown"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2020-12-01","objectID":"/2020/markdown/","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2020/markdown/"},{"categories":["Markdown"],"content":" 目录 {:toc} 1. 斜体和粗体 *斜体*或_斜体_ **粗体** ***加粗斜体*** ~~删除线~~ view 斜体或_斜体_ 粗体 加粗斜体 删除线 2. 分级标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 由于用了[TOC]标记编辑器会把所有标题写到目录大纲中，在这里写的演示标题也会列进去，所以就不演示了。同学们自己在编辑器中观察，很简单，一级标题字号最大，依级递减。 3. 超链接 Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多。 3.1. 行内式 语法说明： []里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。链接地址与链接标题前有一个空格。 欢迎来到[Demi的随笔和技术空间](https://yuhongjun.github.io/) 欢迎来到[Demi的随笔和技术空间](https://yuhongjun.github.io/ \"Demi的随笔和技术空间\") view 欢迎来到Demi的随笔和技术空间 欢迎来到Demi的随笔和技术空间 3.2. 参考式 参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。 语法说明： 参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。 如果链接文字本身可以做为链接标记，你也可以写成[链接文字][] [链接文字]：链接地址的形式，见代码的最后一行。 我经常去的几个网站[Google][1],[Demi的随笔和技术空间][2],[Demi的随笔和技术空间][]。 [1]:http://www.google.com [2]:https://yuhongjun.github.io/ \"Demi的随笔和技术空间\" [Demi的随笔和技术空间]:https://yuhongjun.github.io/ view 我经常去的几个网站Google,Demi的随笔和技术空间,Demi的随笔和技术空间。 3.3. 自动链接 语法说明： Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用\u003c\u003e包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： \u003chttp://example.com/\u003e \u003caddress@example.com\u003e view http://example.com/ address@example.com 4. 锚点 网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。 注意： Markdown Extra 只支持在标题后插入锚点，其它地方无效。 Leanote 编辑器右侧显示效果区域暂时不支持锚点跳转，所以点来点去发现没有跳转不必惊慌，但是你发布成笔记或博文后是支持跳转的。 ## 0. 跳转测试{#index} 跳转到[跳转测试](#index) 5. 列表 5.1. 无序列表 使用 *，+，- 表示无序列表。 - 无序列表项 一 - 无序列表项 二 - 无序列表项 三 view 无序列表项 一 无序列表项 二 无序列表项 三 5.2. 有序列表 有序列表则使用数字接着一个英文句点。 1. 有序列表项 一 2. 有序列表项 二 3. 有序列表项 三 view 有序列表项 一 有序列表项 二 有序列表项 三 5.3. 定义型列表 语法说明： 定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab) 代码块 1 Markdown: 轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格）代码块 2: 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） view 代码块 1 Markdown 轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格） 代码块 2 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 5.3. 列表缩进 语法说明： 列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。 * 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ * 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 view 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 5.4. 包含段落的列表 语法说明： 列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符（显示效果与代码一致）： * 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！* 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 view 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。 5.5. 包含引用的列表 语法说明： 如果要在列表项目内放进引用，那 \u003e 就需要缩进： * 阅读的方法: \u003e 打开书本。 \u003e 打开电灯。 view 阅读的方法: 打开书本。 打开电灯。 5.6. 包含代码区块的引用 语法说明： 如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符： 5.7. 一个特殊情况 在特殊情况下，项目列表很可能会不小心产生，像是下面这样的写法： 1986. What a great season. 会显示成： What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠： 1986\\. What a great season. 才会正常显示成： 1986. What a great season. 6. 引用 语法说明： 引用需要在被引用的文本前加上\u003e符号。 \u003e 这是一个有两段文字的引用,无意义的占行文字1.无意义的占行文字2.\u003e 无意义的占行文字3.无意义的占行文字4. view 这是一个有两段文字的引用, 无意义的占行文字1. 无意义的占行文字2. 无意义的占行文字3. 无意义的占行文字4. 6.1. 引用的多层嵌套 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 \u003e ： \u003e\u003e\u003e 请问 Markdwon 怎么用？ - 小白\u003e\u003e 自己看教程！ - 愤青\u003e 教程在哪？ - 小白 请问 Markdwon 怎么用？ - 小白 自己看教程！ - 愤青 教程在哪？ - 小白 6.2. 引用其它要素 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： \u003e 1. 这是第一行列表项。\u003e 2. 这是第二行列表项。\u003e \u003e 给出一些例子代码：\u003e \u003e return shell_exec(\"echo $input | $markdown_script\"); 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(\"echo $input | $markd","date":"2020-12-01","objectID":"/2020/markdown/:0:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/2020/markdown/"},{"categories":["documentation"],"content":"探索 Hugo - LoveIt 主题的全部内容和背后的核心概念.","date":"2020-03-06","objectID":"/2020/theme-documentation-basics/","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/theme-documentation-basics/"},{"categories":["documentation"],"content":"探索 Hugo - LoveIt 主题的全部内容和背后的核心概念. ","date":"2020-03-06","objectID":"/2020/theme-documentation-basics/:0:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/theme-documentation-basics/"},{"categories":["documentation"],"content":"1 准备 由于 Hugo 提供的便利性, Hugo 本身是这个主题唯一的依赖. 直接安装满足你操作系统 (Windows, Linux, macOS) 的最新版本  Hugo (\u003e 0.62.0). 为什么不支持早期版本的 Hugo? 由于 Markdown 渲染钩子函数 在 Hugo 圣诞节版本 中被引入, 本主题只支持高于 0.62.0 的 Hugo 版本. 推荐使用 Hugo extended 版本 由于这个主题的一些特性需要将  SCSS 转换为  CSS, 推荐使用 Hugo extended 版本来获得更好的使用体验. ","date":"2020-03-06","objectID":"/2020/theme-documentation-basics/:1:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/theme-documentation-basics/"},{"categories":["documentation"],"content":"2 安装 以下步骤可帮助你初始化新网站. 如果你根本不了解 Hugo, 我们强烈建议你按照此 快速入门文档 进一步了解它. ","date":"2020-03-06","objectID":"/2020/theme-documentation-basics/:2:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.1 创建你的项目 Hugo 提供了一个 new 命令来创建一个新的网站: hugo new site my_website cd my_website ","date":"2020-03-06","objectID":"/2020/theme-documentation-basics/:2:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.2 安装主题 LoveIt 主题的仓库是: https://github.com/dillonzq/LoveIt. 你可以下载主题的 最新版本  .zip 文件 并且解压放到 themes 目录. 另外, 也可以直接把这个主题克隆到 themes 目录: git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 或者, 初始化你的项目目录为 git 仓库, 并且把主题仓库作为你的网站目录的子模块: git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt ","date":"2020-03-06","objectID":"/2020/theme-documentation-basics/:2:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.3 基础配置 以下是 LoveIt 主题的基本配置: baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的全新 Hugo 网站\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" [params] # LoveIt 主题版本 version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false Note 在构建网站时, 你可以使用 --theme 选项设置主题. 但是, 我建议你修改配置文件 (config.toml) 将本主题设置为默认主题. ","date":"2020-03-06","objectID":"/2020/theme-documentation-basics/:2:3","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.4 创建你的第一篇文章 以下是创建第一篇文章的方法: hugo new posts/first_post.md 通过添加一些示例内容并替换文件开头的标题, 你可以随意编辑文章. Note 默认情况下, 所有文章和页面均作为草稿创建. 如果想要渲染这些页面, 请从元数据中删除属性 draft: true, 设置属性 draft: false 或者为 hugo 命令添加 -D/--buildDrafts 参数. ","date":"2020-03-06","objectID":"/2020/theme-documentation-basics/:2:4","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.5 在本地启动网站 使用以下命令启动网站: hugo serve 去查看 http://localhost:1313. 基本配置下的预览基本配置下的预览 \" 基本配置下的预览 Tip 当你运行 hugo serve 时, 当文件内容更改时, 页面会随着更改自动刷新. Note 由于本主题使用了 Hugo 中的 .Scratch 来实现一些特性, 非常建议你为 hugo server 命令添加 --disableFastRender 参数来实时预览你正在编辑的文章页面. hugo serve --disableFastRender ","date":"2020-03-06","objectID":"/2020/theme-documentation-basics/:2:5","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.6 构建网站 当你准备好部署你的网站时, 运行以下命令: hugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上. Tip 网站内容可以通过 Netlify 自动发布和托管 (了解有关通过 Netlify 进行 HUGO 自动化部署 的更多信息). 或者, 您可以使用 AWS Amplify, Github pages, Render 以及更多… ","date":"2020-03-06","objectID":"/2020/theme-documentation-basics/:2:6","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/theme-documentation-basics/"},{"categories":["documentation"],"content":"3 配置 ","date":"2020-03-06","objectID":"/2020/theme-documentation-basics/:3:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.1 网站配置 除了 Hugo 全局配置 和 菜单配置 之外, LoveIt 主题还允许您在网站配置中定义以下参数 (这是一个示例 config.toml, 其内容为默认值). 请打开下面的代码块查看完整的示例配置 : [params] # LoveIt 主题版本 version = \"0.2.X\" # 网站描述 description = \"这是我的全新 Hugo 网站\" # 网站关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL avatarURL = \"/images/avatar.png\" # 主页显示的网站标题 (支持 HTML 格式) title = \"\" # 主页显示的网站副标题 subtitle = \"这是我的全新 Hugo 网站\" # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \"\" # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \"hiddenFromHomePage\" 时的默认行为 defaultHiddenFromHomePage = false # 作者的社交信息设置 [params.social] GitHub = \"xxxx\" Linkedin = \"\" Twitter = \"xxxx\" Instagram = \"xxxx\" Facebook = \"xxxx\" Telegram = \"xxxx\" Medium = \"\" Gitlab = \"\" Youtubelegacy = \"\" Youtubecustom = \"\" Youtubechannel = \"\" Tumblr = \"\" Quora = \"\" Keybase = \"\" Pinterest = \"\" Reddit = \"\" Codepen = \"\" FreeCodeCamp = \"\" Bitbucket = \"\" Stackoverflow = \"\" Weibo = \"\" Odnoklassniki = \"\" VK = \"\" Flickr = \"\" Xing = \"\" Snapchat = \"\" Soundcloud = \"\" Spotify = \"\" Bandcamp = \"\" Paypal = \"\" Fivehundredpx = \"\" Mix = \"\" Goodreads = \"\" Lastfm = \"\" Foursquare = \"\" Hackernews = \"\" Kickstarter = \"\" Patreon = \"\" Steam = \"\" Twitch = \"\" Strava = \"\" Skype = \"\" Whatsapp = \"\" Zhihu = \"\" Douban = \"\" Angellist = \"\" Slidershare = \"\" Jsfiddle = \"\" Deviantart = \"\" Behance = \"\" Dribbble = \"\" Wordpress = \"\" Vine = \"\" Googlescholar = \"\" Researchgate = \"\" Mastodon = \"\" Thingiverse = \"\" Devto = \"\" Gitea = \"\" XMPP = \"\" Matrix = \"\" Bilibili = \"\" Email = \"xxxx@xxxx.com\" RSS = true # # 文章页面配置 [params.page] # 是否在主页隐藏一篇文章 hiddenFromHomePage = false # 是否在搜索结果中隐藏一篇文章 hiddenFromSearch = false # 是否使用 twemoji twemoji = false # 是否使用 lightgallery lightgallery = false # 是否使用 ruby 扩展语法 ruby = true # 是否使用 fraction 扩展语法 fraction = true # 是否使用 fontawesome 扩展语法 fontawesome = true # 是否在文章页面显示原始 Markdown 文档链接 linkToMarkdown = true # 是否在 RSS 中显示全文内容 rssFullText = ","date":"2020-03-06","objectID":"/2020/theme-documentation-basics/:3:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.2 网站图标, 浏览器配置, 网站清单 强烈建议你把: apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在 /static 目录. 利用 https://realfavicongenerator.net/ 可以很容易地生成这些文件. 可以自定义 browserconfig.xml 和 site.webmanifest 文件来设置 theme-color 和 background-color. ","date":"2020-03-06","objectID":"/2020/theme-documentation-basics/:3:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.3 自定义样式 Note Hugo extended 版本对于自定义样式是必需的. 通过定义自定义 .scss 样式文件, LoveIt 主题支持可配置的样式. 包含自定义 .scss 样式文件的目录相对于 你的项目根目录 的路径为 assets/css. 在 assets/css/_override.scss 中, 你可以覆盖 themes/LoveIt/assets/css/_variables.scss 中的变量以自定义样式. 这是一个例子: @import url('https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026display=swap\u0026subset=latin-ext'); $code-font-family: Fira Mono, Source Code Pro, Menlo, Consolas, Monaco, monospace; 在 assets/css/_custom.scss 中, 你可以添加一些 CSS 样式代码以自定义样式. ","date":"2020-03-06","objectID":"/2020/theme-documentation-basics/:3:3","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/theme-documentation-basics/"},{"categories":["documentation"],"content":"4 多语言和 i18n LoveIt 主题完全兼容 Hugo 的多语言模式, 并且支持在网页上切换语言. 语言切换语言切换 \" 语言切换 ","date":"2020-03-06","objectID":"/2020/theme-documentation-basics/:4:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.1 兼容性 语言 Hugo 代码 HTML lang 属性 主题文档 Lunr.js 支持 英语 en en 简体中文 zh-cn zh-CN 法语 fr fr 波兰语 pl pl 巴西葡萄牙语 pt-br pt-BR 意大利语 it it 西班牙语 es es 德语 de de 塞尔维亚语 pl pl 俄语 ru ru 罗马尼亚语 ro ro 越南语 vi vi ","date":"2020-03-06","objectID":"/2020/theme-documentation-basics/:4:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.2 基本配置 学习了 Hugo如何处理多语言网站 之后, 请在 站点配置 中定义你的网站语言. 例如, 一个支持英语, 中文和法语的网站配置: # [en, zh-cn, fr, pl, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" [languages] [languages.en] weight = 1 title = \"My New Hugo Site\" languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Posts\" url = \"/posts/\" title = \"\" weight = 1 [[languages.en.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" weight = 2 [[languages.en.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" weight = 3 [languages.zh-cn] weight = 2 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true [[languages.zh-cn.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"文章\" url = \"/posts/\" title = \"\" weight = 1 [[languages.zh-cn.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[languages.zh-cn.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 [languages.fr] weight = 3 title = \"Mon nouveau site Hugo\" languageCode = \"fr\" languageName = \"Français\" [[languages.fr.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Postes\" url = \"/posts/\" title = \"\" weight = 1 [[languages.fr.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Balises\" url = \"/tags/\" title = \"\" weight = 2 [[languages.fr.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Catégories\" url = \"/categories/\" title = \"\" weight = 3 然后, 对于每个新页面, 将语言代码附加到文件名中. 单个文件 my-page.md 需要分为三个文件: 英语: my-page.en.md 中文: my-page.zh-cn.md 法语: my-page.fr.md Note 请注意, 菜单中仅显示翻译的页面. 它不会替换为默认语言内容. Tip 也可以使用 文章前置参数 来翻译网址. ","date":"2020-03-06","objectID":"/2020/theme-documentation-basics/:4:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.3 修改默认的翻译字符串 翻译字符串用于在主题中使用的常见默认值. 目前提供一些语言的翻译, 但你可能自定义其他语言或覆盖默认值. 要覆盖默认值, 请在你项目的 i18n 目录 i18n/\u003clanguageCode\u003e.toml 中创建一个新文件，并从 themes/LoveIt/i18n/en.toml 中获得提示. 另外, 由于你的翻译可能会帮助到其他人, 请花点时间通过  创建一个 PR 来贡献主题翻译, 谢谢! ","date":"2020-03-06","objectID":"/2020/theme-documentation-basics/:4:3","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/theme-documentation-basics/"},{"categories":["documentation"],"content":"5 搜索 基于 Lunr.js 或 algolia, LoveIt 主题支持搜索功能. ","date":"2020-03-06","objectID":"/2020/theme-documentation-basics/:5:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/theme-documentation-basics/"},{"categories":["documentation"],"content":"5.1 输出配置 为了生成搜索功能所需要的 index.json, 请在你的 网站配置 中添加 JSON 输出文件类型到 outputs 部分的 home 字段中. [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2020-03-06","objectID":"/2020/theme-documentation-basics/:5:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/theme-documentation-basics/"},{"categories":["documentation"],"content":"5.2 搜索配置 基于 Hugo 生成的 index.json 文件, 你可以激活搜索功能. 这是你的 网站配置 中的搜索部分: [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" 怎样选择搜索引擎? 以下是两种搜索引擎的对比: lunr: 简单, 无需同步 index.json, 没有 contentLength 的限制, 但占用带宽大且性能低 (特别是中文需要一个较大的分词依赖库) algolia: 高性能并且占用带宽低, 但需要同步 index.json 且有 contentLength 的限制 文章内容被 h2 和 h3 HTML 标签切分来提高查询效果并且基本实现全文搜索. contentLength 用来限制 h2 和 h3 HTML 标签开头的内容部分的最大长度. 关于 algolia 的使用技巧 你需要上传 index.json 到 algolia 来激活搜索功能. 你可以使用浏览器来上传 index.json 文件但是一个自动化的脚本可能效果更好. Algolia Atomic 是一个不错的选择. 为了兼容 Hugo 的多语言模式, 你需要上传不同语言的 index.json 文件到对应的 algolia index, 例如 zh-cn/index.json 或 fr/index.json… ","date":"2020-03-06","objectID":"/2020/theme-documentation-basics/:5:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/2020/theme-documentation-basics/"},{"categories":["documentation"],"content":"了解如何在 LoveIt 主题中快速, 直观地创建和组织内容.","date":"2020-03-05","objectID":"/2020/theme-documentation-content/","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/2020/theme-documentation-content/"},{"categories":["documentation"],"content":"了解如何在 LoveIt 主题中快速, 直观地创建和组织内容. ","date":"2020-03-05","objectID":"/2020/theme-documentation-content/:0:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/2020/theme-documentation-content/"},{"categories":["documentation"],"content":"1 内容组织 以下是一些方便你清晰管理和生成文章的目录结构建议: 保持博客文章存放在 content/posts 目录, 例如: content/posts/我的第一篇文章.md 保持简单的静态页面存放在 content 目录, 例如: content/about.md 本地资源组织 本地资源引用 有三种方法来引用图片和音乐等本地资源: 使用页面包中的页面资源. 你可以使用适用于 Resources.GetMatch 的值或者直接使用相对于当前页面目录的文件路径来引用页面资源. 将本地资源放在 assets 目录中, 默认路径是 /assets. 引用资源的文件路径是相对于 assets 目录的. 将本地资源放在 static 目录中, 默认路径是 /static. 引用资源的文件路径是相对于 static 目录的. 引用的优先级符合以上的顺序. 在这个主题中的很多地方可以使用上面的本地资源引用, 例如 链接, 图片, image shortcode, music shortcode 和前置参数中的部分参数. 页面资源或者 assets 目录中的图片处理会在未来的版本中得到支持. 非常酷的功能! ","date":"2020-03-05","objectID":"/2020/theme-documentation-content/:1:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/2020/theme-documentation-content/"},{"categories":["documentation"],"content":"2 前置参数 Hugo 允许你在文章内容前面添加 yaml, toml 或者 json 格式的前置参数. Note 不是所有的以下前置参数都必须在你的每篇文章中设置. 只有在文章的参数和你的 网站设置 中的 page 部分不一致时才有必要这么做. 这是一个前置参数例子: ---title:\"我的第一篇文章\"subtitle:\"\"date:2020-03-04T15:58:26+08:00lastmod:2020-03-04T15:58:26+08:00draft:trueauthor:\"\"authorLink:\"\"description:\"\"license:\"\"images:[]tags:[]categories:[]featuredImage:\"\"featuredImagePreview:\"\"hiddenFromHomePage:falsehiddenFromSearch:falsetwemoji:falselightgallery:trueruby:truefraction:truefontawesome:truelinkToMarkdown:truerssFullText:falsetoc:enable:trueauto:truecode:copy:true# ...math:enable:true# ...mapbox:accessToken:\"\"# ...share:enable:true# ...comment:enable:true# ...library:css:# someCSS = \"some.css\"# 位于 \"assets/\"# 或者# someCSS = \"https://cdn.example.com/some.css\"js:# someJS = \"some.js\"# 位于 \"assets/\"# 或者# someJS = \"https://cdn.example.com/some.js\"seo:images:[]# ...--- title: 文章标题. subtitle: 文章副标题. date: 这篇文章创建的日期时间. 它通常是从文章的前置参数中的 date 字段获取的, 但是也可以在 网站配置 中设置. lastmod: 上次修改内容的日期时间. draft: 如果设为 true, 除非 hugo 命令使用了 --buildDrafts/-D 参数, 这篇文章不会被渲染. author: 文章作者. authorLink: 文章作者的链接. description: 文章内容的描述. license: 这篇文章特殊的许可. images: 页面图片, 用于 Open Graph 和 Twitter Cards. tags: 文章的标签. categories: 文章所属的类别. featuredImage: 文章的特色图片. featuredImagePreview: 用在主页预览的文章特色图片. hiddenFromHomePage: 如果设为 true, 这篇文章将不会显示在主页上. hiddenFromSearch: 如果设为 true, 这篇文章将不会显示在搜索结果中. twemoji: 如果设为 true, 这篇文章会使用 twemoji. lightgallery: 如果设为 true, 文章中的图片将可以按照画廊形式呈现. ruby: 如果设为 true, 这篇文章会使用 上标注释扩展语法. fraction: 如果设为 true, 这篇文章会使用 分数扩展语法. fontawesome: 如果设为 true, 这篇文章会使用 Font Awesome 扩展语法. linkToMarkdown: 如果设为 true, 内容的页脚将显示指向原始 Markdown 文件的链接. rssFullText: 如果设为 true, 在 RSS 中将会显示全文内容. toc: 和 网站配置 中的 params.page.toc 部分相同. code: 和 网站配置 中的 params.page.code 部分相同. math: 和 网站配置 中的 params.page.math 部分相同. mapbox: 和 网站配置 中的 params.page.mapbox 部分相同. share: 和 网站配置 中的 params.page.share 部分相同. comment: 和 网站配置 中的 params.page.comment 部分相同. library: 和 网站配置 中的 params.page.library 部分相同. seo: 和 网站配置 中的 params.page.seo 部分相同. Tip featuredImage 和 featuredImagePreview 支持本地资源引用的完整用法. 如果带有在前置参数中设置了 name: featured-image 或 name: featured-image-preview 属性的页面资源, 没有必要在设置 featuredImage 或 featuredImagePreview: resources:- name:featured-imagesrc:featured-image.jpg- name:featured-image-previewsrc:featured-image-preview.jpg ","date":"2020-03-05","objectID":"/2020/theme-documentation-content/:2:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/2020/theme-documentation-content/"},{"categories":["documentation"],"content":"3 内容摘要 LoveIt 主题使用内容摘要在主页中显示大致文章信息。Hugo 支持生成文章的摘要. 文章摘要预览文章摘要预览 \" 文章摘要预览 ","date":"2020-03-05","objectID":"/2020/theme-documentation-content/:3:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/2020/theme-documentation-content/"},{"categories":["documentation"],"content":"自动摘要拆分 默认情况下, Hugo 自动将内容的前 70 个单词作为摘要. 你可以通过在 网站配置 中设置 summaryLength 来自定义摘要长度. 如果您要使用 CJK中文/日语/韩语 语言创建内容, 并且想使用 Hugo 的自动摘要拆分功能，请在 网站配置 中将 hasCJKLanguage 设置为 true. ","date":"2020-03-05","objectID":"/2020/theme-documentation-content/:3:1","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/2020/theme-documentation-content/"},{"categories":["documentation"],"content":"手动摘要拆分 另外, 你也可以添加 \u003c!--more--\u003e 摘要分割符来拆分文章生成摘要. 摘要分隔符之前的内容将用作该文章的摘要. Note 请小心输入\u003c!--more--\u003e ; 即全部为小写且没有空格. ","date":"2020-03-05","objectID":"/2020/theme-documentation-content/:3:2","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/2020/theme-documentation-content/"},{"categories":["documentation"],"content":"前置参数摘要 你可能希望摘要不是文章开头的文字. 在这种情况下, 你可以在文章前置参数的 summary 变量中设置单独的摘要. ","date":"2020-03-05","objectID":"/2020/theme-documentation-content/:3:3","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/2020/theme-documentation-content/"},{"categories":["documentation"],"content":"使用文章描述作为摘要 你可能希望将文章前置参数中的 description 变量的内容作为摘要. 你仍然需要在文章开头添加 \u003c!--more--\u003e 摘要分割符. 将摘要分隔符之前的内容保留为空. 然后 LoveIt 主题会将你的文章描述作为摘要. ","date":"2020-03-05","objectID":"/2020/theme-documentation-content/:3:4","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/2020/theme-documentation-content/"},{"categories":["documentation"],"content":"摘要选择的优先级顺序 由于可以通过多种方式指定摘要, 因此了解顺序很有用. 如下: 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 但分隔符之前没有内容, 则使用描述作为摘要. 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 则将按照手动摘要拆分的方法获得摘要. 如果文章前置参数中有摘要变量, 那么将以该值作为摘要. 按照自动摘要拆分方法. Note 不建议在摘要内容中包含富文本块元素, 这会导致渲染错误. 例如代码块, 图片, 表格等. ","date":"2020-03-05","objectID":"/2020/theme-documentation-content/:3:5","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/2020/theme-documentation-content/"},{"categories":["documentation"],"content":"4 Markdown 基本语法 这部分内容在 Markdown 基本语法页面 中介绍. ","date":"2020-03-05","objectID":"/2020/theme-documentation-content/:4:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/2020/theme-documentation-content/"},{"categories":["documentation"],"content":"5 Markdown 扩展语法 LoveIt 主题提供了一些扩展的语法便于你撰写文章. ","date":"2020-03-05","objectID":"/2020/theme-documentation-content/:5:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/2020/theme-documentation-content/"},{"categories":["documentation"],"content":"Emoji 支持 这部分内容在 Emoji 支持页面 中介绍. ","date":"2020-03-05","objectID":"/2020/theme-documentation-content/:5:1","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/2020/theme-documentation-content/"},{"categories":["documentation"],"content":"数学公式 LoveIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. Tip 有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 清单. 公式块 默认的公式块分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 行内公式 默认的行内公式分割符是 $/$ 和 \\\\(/\\\\): $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) 呈现的输出效果如下: $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) Tip 你可以在 网站配置 中自定义公式块和行内公式的分割符. Copy-tex Copy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. mhchem mhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-03-05","objectID":"/2020/theme-documentation-content/:5:2","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/2020/theme-documentation-content/"},{"categories":["documentation"],"content":"字符注音或者注释 LoveIt 主题支持一种 字符注音或者注释 Markdown 扩展语法: [Hugo]^(一个开源的静态网站生成工具) 呈现的输出效果如下: Hugo一个开源的静态网站生成工具 ","date":"2020-03-05","objectID":"/2020/theme-documentation-content/:5:3","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/2020/theme-documentation-content/"},{"categories":["documentation"],"content":"分数 LoveIt 主题支持一种 分数 Markdown 扩展语法: [浅色]/[深色] [99]/[100] 呈现的输出效果如下: 浅色/深色 90/100 ","date":"2020-03-05","objectID":"/2020/theme-documentation-content/:5:4","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/2020/theme-documentation-content/"},{"categories":["documentation"],"content":"Font Awesome LoveIt 主题使用 Font Awesome 作为图标库. 你同样可以在文章中轻松使用这些图标. 从 Font Awesome 网站 上获取所需的图标 class. 去露营啦! :(fas fa-campground fa-fw): 很快就回来. 真开心! :(far fa-grin-tears): 呈现的输出效果如下: 去露营啦!  很快就回来. 真开心! ","date":"2020-03-05","objectID":"/2020/theme-documentation-content/:5:5","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/2020/theme-documentation-content/"},{"categories":["documentation"],"content":"转义字符 在某些特殊情况下 (编写这个主题文档时 ), 你的文章内容会与 Markdown 的基本或者扩展语法冲突, 并且无法避免. 转义字符语法可以帮助你渲染出想要的内容: {?X} -\u003e X 例如, 两个 : 会启用 emoji 语法. 但有时候这不是你想要的结果. 可以像这样使用转义字符语法: {?:}joy: 呈现的输出效果如下: :joy: 而不是 😂 Tip 这个方法可以间接解决一个还未解决的 Hugo 的 issue. 另一个例子是: [link{?]}(#escape-character) 呈现的输出效果如下: [link](#escape-character) 而不是 link. ","date":"2020-03-05","objectID":"/2020/theme-documentation-content/:5:6","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/2020/theme-documentation-content/"},{"categories":["documentation"],"content":"Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁.","date":"2020-03-04","objectID":"/2020/theme-documentation-built-in-shortcodes/","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/2020/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁. Hugo 使用 Markdown 为其简单的内容格式. 但是, Markdown 在很多方面都无法很好地支持. 你可以使用纯 HTML 来扩展可能性. 但这恰好是一个坏主意. 大家使用 Markdown, 正是因为它即使不经过渲染也可以轻松阅读. 应该尽可能避免使用 HTML 以保持内容简洁. 为了避免这种限制, Hugo 创建了 shortcodes. shortcode 是一个简单代码段, 可以生成合理的 HTML 代码, 并且符合 Markdown 的设计哲学. Hugo 附带了一组预定义的 shortcodes, 它们实现了一些非常常见的用法. 提供这些 shortcodes 是为了方便保持你的 Markdown 内容简洁. ","date":"2020-03-04","objectID":"/2020/theme-documentation-built-in-shortcodes/:0:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/2020/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"1 figure figure 的文档 一个 figure 示例: {{\u003c figure src=\"/images/lighthouse.jpg\" title=\"Lighthouse (figure)\" \u003e}} 呈现的输出效果如下: Lighthouse (figure) 输出的 HTML 看起来像这样: \u003cfigure\u003e \u003cimg src=\"/images/lighthouse.jpg\"/\u003e \u003cfigcaption\u003e \u003ch4\u003eLighthouse (figure)\u003c/h4\u003e \u003c/figcaption\u003e \u003c/figure\u003e ","date":"2020-03-04","objectID":"/2020/theme-documentation-built-in-shortcodes/:1:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/2020/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"2 gist gist 的文档 一个 gist 示例: {{\u003c gist spf13 7896402 \u003e}} 呈现的输出效果如下: 输出的 HTML 看起来像这样: \u003cscript type=\"application/javascript\" src=\"https://gist.github.com/spf13/7896402.js\"\u003e\u003c/script\u003e ","date":"2020-03-04","objectID":"/2020/theme-documentation-built-in-shortcodes/:2:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/2020/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"3 highlight highlight 的文档 一个 highlight 示例: {{\u003c highlight html \u003e}} \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e {{\u003c /highlight \u003e}} 呈现的输出效果如下: \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e ","date":"2020-03-04","objectID":"/2020/theme-documentation-built-in-shortcodes/:3:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/2020/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"4 instagram instagram 的文档 一个 instagram 示例: {{\u003c instagram BWNjjyYFxVx hidecaption \u003e}} 呈现的输出效果如下: ","date":"2020-03-04","objectID":"/2020/theme-documentation-built-in-shortcodes/:4:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/2020/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"5 param param 的文档 一个 param 示例: {{\u003c param description \u003e}} 呈现的输出效果如下: Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁. ","date":"2020-03-04","objectID":"/2020/theme-documentation-built-in-shortcodes/:5:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/2020/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"6 ref 和 relref ref 和 relref 的文档 ","date":"2020-03-04","objectID":"/2020/theme-documentation-built-in-shortcodes/:6:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/2020/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"7 tweet tweet 的文档 一个 tweet 示例: {{\u003c tweet 877500564405444608 \u003e}} 呈现的输出效果如下: Hugo 0.24 Released: Big archetype update + @Netlify _redirects etc. file supporthttps://t.co/X94FmYDEZJ #gohugo #golang @spf13 @bepsays — GoHugo.io (@GoHugoIO) June 21, 2017 ","date":"2020-03-04","objectID":"/2020/theme-documentation-built-in-shortcodes/:7:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/2020/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"8 vimeo vimeo 的文档 一个 vimeo 示例: {{\u003c vimeo 146022717 \u003e}} 呈现的输出效果如下: ","date":"2020-03-04","objectID":"/2020/theme-documentation-built-in-shortcodes/:8:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/2020/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"9 youtube youtube 的文档 一个 youtube 示例: {{\u003c youtube w7Ft2ymGmfc \u003e}} 呈现的输出效果如下: ","date":"2020-03-04","objectID":"/2020/theme-documentation-built-in-shortcodes/:9:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/2020/theme-documentation-built-in-shortcodes/"},{"categories":["Markdown"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2020-12-01","objectID":"/2020/markdown-basic/","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"这篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 语法示例. Note 这篇文章借鉴了一篇很棒的来自 Grav 的文章. 如果你想了解 Loveit 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面. 事实上, 编写 Web 内容很麻烦. WYSIWYG所见即所得 编辑器帮助减轻了这一任务. 但通常会导致代码太糟, 或更糟糕的是, 网页也会很丑. 没有通常伴随的所有复杂和丑陋的问题, Markdown 是一种更好的生成 HTML 内容的方式. 一些主要好处是: Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者如是说: Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式! Tip  将此页保存为书签，以备将来参考! ","date":"2020-12-01","objectID":"/2020/markdown-basic/:0:0","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID 要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e ","date":"2020-12-01","objectID":"/2020/markdown-basic/:1:0","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"2 注释 注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2020-12-01","objectID":"/2020/markdown-basic/:2:0","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"3 水平线 HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2020-12-01","objectID":"/2020/markdown-basic/:3:0","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"4 段落 按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2020-12-01","objectID":"/2020/markdown-basic/:4:0","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"5 内联 HTML 元素 如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e 这是 \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Markdown 格式的段落. ","date":"2020-12-01","objectID":"/2020/markdown-basic/:5:0","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"6 强调 ","date":"2020-12-01","objectID":"/2020/markdown-basic/:6:0","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"加粗 用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. **渲染为粗体** __渲染为粗体__ 输出的 HTML 看起来像这样: \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2020-12-01","objectID":"/2020/markdown-basic/:6:1","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"斜体 用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. *渲染为斜体* _渲染为斜体_ 输出的 HTML 看起来像这样: \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2020-12-01","objectID":"/2020/markdown-basic/:6:2","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"删除线 按照 GFMGitHub flavored Markdown 你可以使用删除线. ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2020-12-01","objectID":"/2020/markdown-basic/:6:3","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"组合 加粗, 斜体, 和删除线可以 组合使用. ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除线和斜体*~~ ~~***加粗, 斜体和删除线***~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2020-12-01","objectID":"/2020/markdown-basic/:6:4","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"7 引用 用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2020-12-01","objectID":"/2020/markdown-basic/:7:0","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"8 列表 ","date":"2020-12-01","objectID":"/2020/markdown-basic/:8:0","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"无序列表 一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: * 一项内容 - 一项内容 + 一项内容 例如: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2020-12-01","objectID":"/2020/markdown-basic/:8:1","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"有序列表 一系列项的列表, 其中项的顺序确实很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e Tip 如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem ","date":"2020-12-01","objectID":"/2020/markdown-basic/:8:2","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"任务列表 任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框，请在方括号之间添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2020-12-01","objectID":"/2020/markdown-basic/:8:3","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"9 代码 ","date":"2020-12-01","objectID":"/2020/markdown-basic/:9:0","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"行内代码 用 ` 包装行内代码段. 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2020-12-01","objectID":"/2020/markdown-basic/:9:1","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"缩进代码 将几行代码缩进至少四个空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments line 1 of code line 2 of code line 3 of code 输出的 HTML 看起来像这样: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2020-12-01","objectID":"/2020/markdown-basic/:9:2","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"围栏代码块 使用 “围栏” ``` 来生成一段带有语言属性的代码块. ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2020-12-01","objectID":"/2020/markdown-basic/:9:3","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"语法高亮 GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它，只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; Note Hugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息, 包括语法高亮的 shortcode. ","date":"2020-12-01","objectID":"/2020/markdown-basic/:9:4","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"10 表格 通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐 在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2020-12-01","objectID":"/2020/markdown-basic/:10:0","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"11 链接 ","date":"2020-12-01","objectID":"/2020/markdown-basic/:11:0","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上，没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2020-12-01","objectID":"/2020/markdown-basic/:11:1","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage 输出的 HTML 看起来像这样: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2020-12-01","objectID":"/2020/markdown-basic/:11:2","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"定位标记 定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) 将跳转到这些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. Note 定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了. ","date":"2020-12-01","objectID":"/2020/markdown-basic/:11:3","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"12 脚注 脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2020-12-01","objectID":"/2020/markdown-basic/:12:0","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["Markdown"],"content":"13 图片 图片的语法与链接相似, 但包含一个在前面的感叹号. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The StormtroopocatAlt text \" The Stormtroopocat 像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] The DojocatAlt text \" The Dojocat 稍后在文档中提供参考内容, 用来定义 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" Tip LoveIt 主题提供了一个包含更多功能的 图片的 shortcode. 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2020-12-01","objectID":"/2020/markdown-basic/:13:0","tags":["Markdown","HTML"],"title":"Hugo Markdown 基本语法","uri":"/2020/markdown-basic/"},{"categories":["documentation"],"content":"LoveIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode.","date":"2020-03-03","objectID":"/2020/theme-documentation-extended-shortcodes/","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/2020/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"LoveIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode. ","date":"2020-03-03","objectID":"/2020/theme-documentation-extended-shortcodes/:0:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/2020/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"1 style Note Hugo extended 版本对于 style shortcode 是必需的. style shortcode 用来在你的文章中插入自定义样式. style shortcode 有两个位置参数. 第一个参数是自定义样式的内容. 它支持  SASS 中的嵌套语法, 并且 \u0026 指代这个父元素. 第二个参数是包裹你要更改样式的内容的 HTML 标签, 默认值是 div. 一个 style 示例: {{\u003c style \"text-align:right; strong{color:#00b1ff;}\" \u003e}} This is a **right-aligned** paragraph. {{\u003c /style \u003e}} 呈现的输出效果如下: This is a right-aligned paragraph. ","date":"2020-03-03","objectID":"/2020/theme-documentation-extended-shortcodes/:1:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/2020/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"2 link link shortcode 是 Markdown 链接语法 的替代. link shortcode 可以提供一些其它的功能并且可以在代码块中使用. 支持本地资源引用的完整用法. link shortcode 有以下命名参数: href [必需] (第一个位置参数) 链接的目标. content [可选] (第二个位置参数) 链接的内容, 默认值是 href 参数的值. 支持 Markdown 或者 HTML 格式. title [可选] (第三个位置参数) HTML a 标签 的 title 属性, 当悬停在链接上会显示的提示. rel [可选] HTML a 标签 的 rel 补充属性. class [可选] HTML a 标签 的 class 属性. 一个 link 示例: {{\u003c link \"https://assemble.io\" \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" \u003e}} {{\u003c link \"mailto:contact@revolunet.com\" \u003e}} 或者 {{\u003c link href=\"mailto:contact@revolunet.com\" \u003e}} {{\u003c link \"https://assemble.io\" Assemble \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" content=Assemble \u003e}} 呈现的输出效果如下: https://assemble.io mailto:contact@revolunet.com Assemble 一个带有标题的 link 示例: {{\u003c link \"https://github.com/upstage/\" Upstage \"Visit Upstage!\" \u003e}} 或者 {{\u003c link href=\"https://github.com/upstage/\" content=Upstage title=\"Visit Upstage!\" \u003e}} 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage ","date":"2020-03-03","objectID":"/2020/theme-documentation-extended-shortcodes/:2:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/2020/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"3 image image shortcode 是 figure shortcode 的替代. image shortcode 可以充分利用 lazysizes 和 lightgallery.js 两个依赖库. 支持本地资源引用的完整用法. image shortcode 有以下命名参数: src [必需] (第一个位置参数) 图片的 URL. alt [可选] (第二个位置参数) 图片无法显示时的替代文本, 默认值是 src 参数的值. 支持 Markdown 或者 HTML 格式. caption [可选] (第三个位置参数) 图片标题. 支持 Markdown 或者 HTML 格式. title [可选] 当悬停在图片上会显示的提示. class [可选] HTML figure 标签的 class 属性. src_s [可选] 图片缩略图的 URL, 用在画廊模式中, 默认值是 src 参数的值. src_l [可选] 高清图片的 URL, 用在画廊模式中, 默认值是 src 参数的值. height [可选] 图片的 height 属性. width [可选] 图片的 width 属性. linked [可选] 图片是否需要被链接, 默认值是 true. rel [可选] HTML a 标签 的 rel 补充属性, 仅在 linked 属性设置成 true 时有效. 一个 image 示例: {{\u003c image src=\"/images/lighthouse.jpg\" caption=\"Lighthouse (`image`)\" src_s=\"/images/lighthouse-small.jpg\" src_l=\"/images/lighthouse-large.jpg\" \u003e}} 呈现的输出效果如下: Lighthouse (image)\" Lighthouse (image) ","date":"2020-03-03","objectID":"/2020/theme-documentation-extended-shortcodes/:3:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/2020/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"4 admonition admonition shortcode 支持 12 种 帮助你在页面中插入提示的横幅. 支持 Markdown 或者 HTML 格式. Note 一个 注意 横幅 Abstract 一个 摘要 横幅 Info 一个 信息 横幅 Tip 一个 技巧 横幅 Success 一个 成功 横幅 Question 一个 问题 横幅 Warning 一个 警告 横幅 Failure 一个 失败 横幅 Danger 一个 危险 横幅 Bug 一个 Bug 横幅 Example 一个 示例 横幅 Quote 一个 引用 横幅 admonition shortcode 有以下命名参数: type [必需] (第一个位置参数) admonition 横幅的类型, 默认值是 note. title [可选] (第二个位置参数) admonition 横幅的标题, 默认值是 type 参数的值. open [可选] (第三个位置参数) 横幅内容是否默认展开, 默认值是 true. 一个 admonition 示例: {{\u003c admonition type=tip title=\"This is a tip\" open=false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 或者 {{\u003c admonition tip \"This is a tip\" false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 呈现的输出效果如下: This is a tip 一个 技巧 横幅 ","date":"2020-03-03","objectID":"/2020/theme-documentation-extended-shortcodes/:4:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/2020/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5 mermaid mermaid 是一个可以帮助你在文章中生成图表和流程图的库, 类似 Markdown 的语法. 只需将你的 mermaid 代码插入 mermaid shortcode 中即可. ","date":"2020-03-03","objectID":"/2020/theme-documentation-extended-shortcodes/:5:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/2020/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.1 流程图 一个 流程图 mermaid 示例: {{\u003c mermaid \u003e}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: graph LR; A[Hard edge] --|Link text| B(Round edge) B -- C{Decision} C --|One| D[Result one] C --|Two| E[Result two] ","date":"2020-03-03","objectID":"/2020/theme-documentation-extended-shortcodes/:5:1","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/2020/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.2 时序图 一个 时序图 mermaid 示例: {{\u003c mermaid \u003e}} sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! {{\u003c /mermaid \u003e}} 呈现的输出效果如下: sequenceDiagram participant Alice participant Bob Alice-John: Hello John, how are you? loop Healthcheck John-John: Fight against hypochondria end Note right of John: Rational thoughts prevail... John--Alice: Great! John-Bob: How about you? Bob--John: Jolly good! ","date":"2020-03-03","objectID":"/2020/theme-documentation-extended-shortcodes/:5:2","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/2020/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.3 甘特图 一个 甘特图 mermaid 示例: {{\u003c mermaid \u003e}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d {{\u003c /mermaid \u003e}} 呈现的输出效果如下: gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d ","date":"2020-03-03","objectID":"/2020/theme-documentation-extended-shortcodes/:5:3","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/2020/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.4 类图 一个 类图 mermaid 示例: {{\u003c mermaid \u003e}} classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label {{\u003c /mermaid \u003e}} 呈现的输出效果如下: classDiagram Class01 C2 : Where am i? Class09 --* C3 Class09 --| Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 C2: Cool label ","date":"2020-03-03","objectID":"/2020/theme-documentation-extended-shortcodes/:5:4","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/2020/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.5 状态图 一个 状态图 mermaid 示例: {{\u003c mermaid \u003e}} stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: stateDiagram [*] -- Still Still -- [*] Still -- Moving Moving -- Still Moving -- Crash Crash -- [*] ","date":"2020-03-03","objectID":"/2020/theme-documentation-extended-shortcodes/:5:5","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/2020/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.6 Git 图 一个 Git 图 mermaid 示例: {{\u003c mermaid \u003e}} gitGraph: options { \"nodeSpacing\": 100, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch {{\u003c /mermaid \u003e}} 呈现的输出效果如下: gitGraph: options { \"nodeSpacing\": 100, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch ","date":"2020-03-03","objectID":"/2020/theme-documentation-extended-shortcodes/:5:6","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/2020/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5.7 饼图 一个 饼图 mermaid 示例: {{\u003c mermaid \u003e}} pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 {{\u003c /mermaid \u003e}} 呈现的输出效果如下: pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 ","date":"2020-03-03","objectID":"/2020/theme-documentation-extended-shortcodes/:5:7","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/2020/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"6 echarts ECharts 是一个帮助你生成交互式数据可视化的库. ECharts 提供了常规的 折线图, 柱状图, 散点图, 饼图, K线图, 用于统计的 盒形图, 用于地理数据可视化的 地图, 热力图, 线图, 用于关系数据可视化的 关系图, treemap, 旭日图, 多维数据可视化的 平行坐标, 还有用于 BI 的 漏斗图, 仪表盘, 并且支持图与图之间的混搭. 只需在 echarts shortcode 中以 JSON/YAML/TOML格式插入 ECharts 选项即可. 一个 JSON 格式的 echarts 示例: {{\u003c echarts \u003e}} { \"title\": { \"text\": \"折线统计图\", \"top\": \"2%\", \"left\": \"center\" }, \"tooltip\": { \"trigger\": \"axis\" }, \"legend\": { \"data\": [\"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\"], \"top\": \"10%\" }, \"grid\": { \"left\": \"5%\", \"right\": \"5%\", \"bottom\": \"5%\", \"top\": \"20%\", \"containLabel\": true }, \"toolbox\": { \"feature\": { \"saveAsImage\": { \"title\": \"保存为图片\" } } }, \"xAxis\": { \"type\": \"category\", \"boundaryGap\": false, \"data\": [\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"] }, \"yAxis\": { \"type\": \"value\" }, \"series\": [ { \"name\": \"邮件营销\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [120, 132, 101, 134, 90, 230, 210] }, { \"name\": \"联盟广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [220, 182, 191, 234, 290, 330, 310] }, { \"name\": \"视频广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [150, 232, 201, 154, 190, 330, 410] }, { \"name\": \"直接访问\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [320, 332, 301, 334, 390, 330, 320] }, { \"name\": \"搜索引擎\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [820, 932, 901, 934, 1290, 1330, 1320] } ] } {{\u003c /echarts \u003e}} 一个 YAML 格式的 echarts 示例: {{\u003c echarts \u003e}}title:text:折线统计图top:2%left:centertooltip:trigger:axislegend:data:- 邮件营销- 联盟广告- 视频广告- 直接访问- 搜索引擎top:10%grid:left:5%right:5%bottom:5%top:20%containLabel:truetoolbox:feature:saveAsImage:title:保存为图片xAxis:type:categoryboundaryGap:falsedata:- 周一- 周二- 周三- 周四- 周五- 周六- 周日yAxis:type:valueseries:- name:邮件营销type:linestack:总量data:- 120- 132- 101- 134- 90- 230- 210- name:联盟广告type:linestack:总量data:- 220- 182- 191- 234- 290- 330- 310- name:视频广告type:linestack:总量data:- 150- 232- 201- 154- 190- 330- 410- name:直接访问type:linestack:总量data:- 320- 332- 301- 334- 390- 330- 320- name:搜索引擎type:linestack:总量data:- 820- 932- 901- 934- 1290- 1330- 1320{{\u003c /echarts \u003e}} 一个 TOML 格式的 echarts 示例: {{\u003c echarts \u003e}} [title] text = \"折线统计图\" top = \"2%\" left = \"center\" [tooltip] trigger = \"axis\" [legend] data = [ \"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\" ] top = \"10%\" [grid] left = \"5%\" right = \"5%\" bottom = \"5%\" top = \"20%\" containLabel = true [toolbox] [toolbox.feature] [toolbox.feature.saveAsImage] title = \"保存为图片\" [xAxis] type = \"category\" boundaryGap = false data = [ \"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\" ] [yAxis] type = \"value\" [[series]] name = \"邮件营销\" type = \"line\" stack = \"总量\" data = [ 120.0, 132.0, 101.0, 134.0, 90.0, 230.0, 210.0 ] [[series]] name = \"联盟广告\" type = \"line\" stack = \"总量\" data = [ 220.0, 182.0, 191.0, 234.0, 290.0, 330.0, 310.0 ] [[series]] name = \"视频广告\" type = \"line\" stack = \"总量\" data = [ 150.0, 232.0, 201.0, 154.0, 190.0, 330.0, 410.0 ] [[series]] name = \"直接访问\" type = \"line\" stack = \"总量\" data = [ 320.0, 332.0, 301.0, 334.0, 390.0, 330.0, 320.0 ] [[series]] name = \"搜索引擎\" type = \"line\" stack = \"总量\" data = [ 820.0, 932.0, 901.0, 934.0, 1290.0, 1330.0, 1320.0 ] {{\u003c /echarts \u003e}} 呈现的输出效果如下: echarts shortcode 还有以下命名参数: width [可选] (第一个位置参数) 数据可视化的宽度, 默认值是 100%. height [可选] (第二个位置参数) 数据可视化的高度, 默认值是 30rem. ","date":"2020-03-03","objectID":"/2020/theme-documentation-extended-shortcodes/:6:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/2020/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"7 mapbox Mapbox GL JS 是一个 JavaScript 库，它使用 WebGL, 以 vector tiles 和 Mapbox styles 为来源, 将它们渲染成互动式地图. mapbox shortcode 有以下命名参数来使用 Mapbox GL JS: lng [必需] (第一个位置参数) 地图初始中心点的经度, 以度为单位. lat [必需] (第二个位置参数) 地图初始中心点的纬度, 以度为单位. zoom [可选] (第三个位置参数) 地图的初始缩放级别, 默认值是 10. marked [可选] (第四个位置参数) 是否在地图的初始中心点添加图钉, 默认值是 true. light-style [可选] (第五个位置参数) 浅色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. dark-style [可选] (第六个位置参数) 深色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. navigation [可选] 是否添加 NavigationControl, 默认值是前置参数或者网站配置中设置的值. geolocate [可选] 是否添加 GeolocateControl, 默认值是前置参数或者网站配置中设置的值. scale [可选] 是否添加 ScaleControl, 默认值是前置参数或者网站配置中设置的值. fullscreen [可选] 是否添加 FullscreenControl, 默认值是前置参数或者网站配置中设置的值. width [可选] 地图的宽度, 默认值是 100%. height [可选] 地图的高度, 默认值是 20rem. 一个简单的 mapbox 示例: {{\u003c mapbox 121.485 31.233 12 \u003e}} 或者 {{\u003c mapbox lng=121.485 lat=31.233 zoom=12 \u003e}} 呈现的输出效果如下: 一个带有自定义样式的 mapbox 示例: {{\u003c mapbox -122.252 37.453 10 false \"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 或者 {{\u003c mapbox lng=-122.252 lat=37.453 zoom=10 marked=false light-style=\"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/2020/theme-documentation-extended-shortcodes/:7:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/2020/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8 music music shortcode 基于 APlayer 和 MetingJS 提供了一个内嵌的响应式音乐播放器. 有三种方式使用 music shortcode. ","date":"2020-03-03","objectID":"/2020/theme-documentation-extended-shortcodes/:8:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/2020/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8.1 自定义音乐 URL 支持本地资源引用的完整用法. music shortcode 有以下命名参数来使用自定义音乐 URL: server [必需] 音乐的链接. type [可选] 音乐的名称. artist [可选] 音乐的创作者. cover [可选] 音乐的封面链接. 一个使用自定义音乐 URL 的 music 示例: {{\u003c music url=\"/music/Wavelength.mp3\" name=Wavelength artist=oldmanyoung cover=\"/images/Wavelength.jpg\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/2020/theme-documentation-extended-shortcodes/:8:1","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/2020/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8.2 音乐平台 URL 的自动识别 music shortcode 有一个命名参数来使用音乐平台 URL 的自动识别: auto [必需]] (第一个位置参数) 用来自动识别的音乐平台 URL, 支持 netease, tencent 和 xiami 平台. 一个使用音乐平台 URL 的自动识别的 music 示例: {{\u003c music auto=\"https://music.163.com/#/playlist?id=60198\" \u003e}} 或者 {{\u003c music \"https://music.163.com/#/playlist?id=60198\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/2020/theme-documentation-extended-shortcodes/:8:2","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/2020/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8.3 自定义音乐平台, 类型和 ID music shortcode 有以下命名参数来使用自定义音乐平台: server [必需] (第一个位置参数) [netease, tencent, kugou, xiami, baidu] 音乐平台. type [必需] (第二个位置参数) [song, playlist, album, search, artist] 音乐类型. id [必需] (第三个位置参数) 歌曲 ID, 或者播放列表 ID, 或者专辑 ID, 或者搜索关键词, 或者创作者 ID. 一个使用自定义音乐平台的 music 示例: {{\u003c music server=\"netease\" type=\"song\" id=\"1868553\" \u003e}} 或者 {{\u003c music netease song 1868553 \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/2020/theme-documentation-extended-shortcodes/:8:3","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/2020/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8.4 其它参数 music shortcode 有一些可以应用于以上三种方式的其它命名参数: theme [可选] 音乐播放器的主题色, 默认值是 #448aff. fixed [可选] 是否开启固定模式, 默认值是 false. mini [可选] 是否开启迷你模式, 默认值是 false. autoplay [可选] 是否自动播放音乐, 默认值是 false. volume [可选] 第一次打开播放器时的默认音量, 会被保存在浏览器缓存中, 默认值是 0.7. mutex [可选] 是否自动暂停其它播放器, 默认值是 true. music shortcode 还有一些只适用于音乐列表方式的其它命名参数: loop [可选] [all, one, none] 音乐列表的循环模式, 默认值是 none. order [可选] [list, random] 音乐列表的播放顺序, 默认值是 list. list-folded [可选] 初次打开的时候音乐列表是否折叠, 默认值是 false. list-max-height [可选] 音乐列表的最大高度, 默认值是 340px. ","date":"2020-03-03","objectID":"/2020/theme-documentation-extended-shortcodes/:8:4","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/2020/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"9 bilibili bilibili shortcode 提供了一个内嵌的用来播放 bilibili 视频的响应式播放器. 如果视频只有一个部分, 则仅需要视频的 BV id, 例如: https://www.bilibili.com/video/BV1Sx411T7QQ 一个 bilibili 示例: {{\u003c bilibili BV1Sx411T7QQ \u003e}} 或者 {{\u003c bilibili id=BV1Sx411T7QQ \u003e}} 呈现的输出效果如下: 如果视频包含多个部分, 则除了视频的 BV id 之外, 还需要 p, 默认值为 1, 例如: https://www.bilibili.com/video/BV1TJ411C7An?p=3 一个带有 p 参数的 bilibili 示例: {{\u003c bilibili BV1TJ411C7An 3 \u003e}} 或者 {{\u003c bilibili id=BV1TJ411C7An p=3 \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/2020/theme-documentation-extended-shortcodes/:9:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/2020/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"10 typeit typeit shortcode 基于 TypeIt 提供了打字动画. 只需将你需要打字动画的内容插入 typeit shortcode 中即可. ","date":"2020-03-03","objectID":"/2020/theme-documentation-extended-shortcodes/:10:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/2020/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"10.1 简单内容 允许使用 Markdown 格式的简单内容, 并且 不包含 富文本的块内容, 例如图像等等… 一个 typeit 示例: {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: 另外, 你也可以自定义 HTML 标签. 一个带有 h4 标签的 typeit 示例: {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/2020/theme-documentation-extended-shortcodes/:10:1","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/2020/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"10.2 代码内容 代码内容也是允许的, 并且通过使用参数 code 指定语言类型可以实习语法高亮. 一个带有 code 参数的 typeit 示例: {{\u003c typeit code=java \u003e}} public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/2020/theme-documentation-extended-shortcodes/:10:2","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/2020/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"10.3 分组内容 默认情况下, 所有打字动画都是同时开始的. 但是有时你可能需要按顺序开始一组 typeit 内容的打字动画. 一组具有相同 group 参数值的 typeit 内容将按顺序开始打字动画. 一个带有 group 参数的 typeit 示例: {{\u003c typeit group=paragraph \u003e}} **首先**, 这个段落开始 {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **然后**, 这个段落开始 {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/2020/theme-documentation-extended-shortcodes/:10:3","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/2020/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"11 script script shortcode 用来在你的文章中插入  Javascript 脚本. Note 脚本内容可以保证在所有的第三方库加载之后按顺序执行. 所以你可以自由地使用第三方库. 一个 script 示例: {{\u003c script \u003e}} console.log('Hello LoveIt!'); {{\u003c /script \u003e}} 你可以在开发者工具的控制台中看到输出. ","date":"2020-03-03","objectID":"/2020/theme-documentation-extended-shortcodes/:11:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/2020/theme-documentation-extended-shortcodes/"},{"categories":["Markdown"],"content":"Hugo 和 LoveIt 中的 Emoji 的用法指南.","date":"2019-10-01","objectID":"/2019/emoji-support/","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"Emoji 可以通过多种方式在 Hugo 项目中启用. emojify 方法可以直接在模板中调用, 或者使用行内 Shortcodes. 要全局使用 emoji, 需要在你的网站配置中设置 enableEmoji 为 true, 然后你就可以直接在文章中输入 emoji 的代码. 它们以冒号开头和结尾，并且包含 emoji 的 代码: 去露营啦! :tent: 很快就回来. 真开心! :joy: 呈现的输出效果如下: 去露营啦! ⛺ 很快就回来. 真开心! 😂 以下符号清单是 emoji 代码的非常有用的参考. ","date":"2019-10-01","objectID":"/2019/emoji-support/:0:0","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"表情与情感 ","date":"2019-10-01","objectID":"/2019/emoji-support/:1:0","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"笑脸表情 图标 代码 图标 代码 😀 grinning 😃 smiley 😄 smile 😁 grin 😆 laughing satisfied 😅 sweat_smile 🤣 rofl 😂 joy 🙂 slightly_smiling_face 🙃 upside_down_face 😉 wink 😊 blush 😇 innocent ","date":"2019-10-01","objectID":"/2019/emoji-support/:1:1","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"爱意表情 图标 代码 图标 代码 😍 heart_eyes 😘 kissing_heart 😗 kissing ☺️ relaxed 😚 kissing_closed_eyes 😙 kissing_smiling_eyes ","date":"2019-10-01","objectID":"/2019/emoji-support/:1:2","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"吐舌头表情 图标 代码 图标 代码 😋 yum 😛 stuck_out_tongue 😜 stuck_out_tongue_winking_eye 😝 stuck_out_tongue_closed_eyes 🤑 money_mouth_face ","date":"2019-10-01","objectID":"/2019/emoji-support/:1:3","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"带手的表情 图标 代码 图标 代码 🤗 hugs 🤔 thinking ","date":"2019-10-01","objectID":"/2019/emoji-support/:1:4","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"中性表情 图标 代码 图标 代码 🤐 zipper_mouth_face 😐 neutral_face 😑 expressionless 😶 no_mouth 😏 smirk 😒 unamused 🙄 roll_eyes 😬 grimacing 🤥 lying_face ","date":"2019-10-01","objectID":"/2019/emoji-support/:1:5","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"困倦的表情 图标 代码 图标 代码 😌 relieved 😔 pensive 😪 sleepy 🤤 drooling_face 😴 sleeping ","date":"2019-10-01","objectID":"/2019/emoji-support/:1:6","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"不适的表情 图标 代码 图标 代码 😷 mask 🤒 face_with_thermometer 🤕 face_with_head_bandage 🤢 nauseated_face 🤧 sneezing_face 😵 dizzy_face ","date":"2019-10-01","objectID":"/2019/emoji-support/:1:7","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"戴帽子的表情 图标 代码 图标 代码 🤠 cowboy_hat_face ","date":"2019-10-01","objectID":"/2019/emoji-support/:1:8","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"戴眼镜的表情 图标 代码 图标 代码 😎 sunglasses 🤓 nerd_face ","date":"2019-10-01","objectID":"/2019/emoji-support/:1:9","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"担心的表情 图标 代码 图标 代码 😕 confused 😟 worried 🙁 slightly_frowning_face ☹ frowning_face 😮 open_mouth 😯 hushed 😲 astonished 😳 flushed 😦 frowning 😧 anguished 😨 fearful 😰 cold_sweat 😥 disappointed_relieved 😢 cry 😭 sob 😱 scream 😖 confounded 😣 persevere 😞 disappointed 😓 sweat 😩 weary 😫 tired_face ","date":"2019-10-01","objectID":"/2019/emoji-support/:1:10","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"否定的表情 图标 代码 图标 代码 😤 triumph 😡 pout rage 😠 angry 😈 smiling_imp 👿 imp 💀 skull ☠️ skull_and_crossbones ","date":"2019-10-01","objectID":"/2019/emoji-support/:1:11","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"特殊打扮的表情 图标 代码 图标 代码 💩 hankey poop shit 🤡 clown_face 👹 japanese_ogre 👺 japanese_goblin 👻 ghost 👽 alien 👾 space_invader 🤖 robot ","date":"2019-10-01","objectID":"/2019/emoji-support/:1:12","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"猫脸表情 图标 代码 图标 代码 😺 smiley_cat 😸 smile_cat 😹 joy_cat 😻 heart_eyes_cat 😼 smirk_cat 😽 kissing_cat 🙀 scream_cat 😿 crying_cat_face 😾 pouting_cat ","date":"2019-10-01","objectID":"/2019/emoji-support/:1:13","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"猴脸表情 图标 代码 图标 代码 🙈 see_no_evil 🙉 hear_no_evil 🙊 speak_no_evil ","date":"2019-10-01","objectID":"/2019/emoji-support/:1:14","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"情感 图标 代码 图标 代码 💋 kiss 💌 love_letter 💘 cupid 💝 gift_heart 💖 sparkling_heart 💗 heartpulse 💓 heartbeat 💞 revolving_hearts 💕 two_hearts 💟 heart_decoration ❣️ heavy_heart_exclamation 💔 broken_heart ❤️ heart 💛 yellow_heart 💚 green_heart 💙 blue_heart 💜 purple_heart 🖤 black_heart 💯 100 💢 anger 💥 boom collision 💫 dizzy 💦 sweat_drops 💨 dash 🕳️ hole 💣 bomb 💬 speech_balloon 👁️‍🗨️ eye_speech_bubble 🗯️ right_anger_bubble 💭 thought_balloon 💤 zzz ","date":"2019-10-01","objectID":"/2019/emoji-support/:1:15","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"人与身体 ","date":"2019-10-01","objectID":"/2019/emoji-support/:2:0","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"张开手掌的手势 图标 代码 图标 代码 👋 wave 🤚 raised_back_of_hand 🖐️ raised_hand_with_fingers_splayed ✋ hand raised_hand 🖖 vulcan_salute ","date":"2019-10-01","objectID":"/2019/emoji-support/:2:1","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"部分手指的手势 图标 代码 图标 代码 👌 ok_hand ✌️ v 🤞 crossed_fingers 🤘 metal 🤙 call_me_hand ","date":"2019-10-01","objectID":"/2019/emoji-support/:2:2","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"一根手指的手势 图标 代码 图标 代码 👈 point_left 👉 point_right 👆 point_up_2 🖕 fu middle_finger 👇 point_down ☝️ point_up ","date":"2019-10-01","objectID":"/2019/emoji-support/:2:3","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"握紧的手势 图标 代码 图标 代码 👍 +1 thumbsup 👎 -1 thumbsdown ✊ fist fist_raised 👊 facepunch fist_oncoming punch 🤛 fist_left 🤜 fist_right ","date":"2019-10-01","objectID":"/2019/emoji-support/:2:4","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"两只手 图标 代码 图标 代码 👏 clap 🙌 raised_hands 👐 open_hands 🤝 handshake 🙏 pray ","date":"2019-10-01","objectID":"/2019/emoji-support/:2:5","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"握住东西的手势 图标 代码 图标 代码 ✍️ writing_hand 💅 nail_care 🤳 selfie ","date":"2019-10-01","objectID":"/2019/emoji-support/:2:6","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"身体部位 图标 代码 图标 代码 💪 muscle 👂 ear 👃 nose 👀 eyes 👁️ eye 👅 tongue 👄 lips ","date":"2019-10-01","objectID":"/2019/emoji-support/:2:7","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"人 图标 代码 图标 代码 👶 baby 👦 boy 👧 girl :blonde_man: blonde_man person_with_blond_hair 👨 man 👩 woman 👱‍♀️ blonde_woman 👴 older_man 👵 older_woman ","date":"2019-10-01","objectID":"/2019/emoji-support/:2:8","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"身体动作 图标 代码 图标 代码 🙍‍♀️ frowning_woman person_frowning 🙍‍♂️ frowning_man 🙎‍♀️ person_with_pouting_face pouting_woman 🙎‍♂️ pouting_man 🙅‍♀️ ng_woman no_good no_good_woman 🙅‍♂️ ng_man no_good_man 🙆‍♀️ ok_woman 🙆‍♂️ ok_man 💁‍♀️ information_desk_person sassy_woman tipping_hand_woman 💁‍♂️ sassy_man tipping_hand_man 🙋‍♀️ raising_hand raising_hand_woman 🙋‍♂️ raising_hand_man 🙇‍♂️ bow bowing_man 🙇‍♀️ bowing_woman 🤦‍♂️ man_facepalming 🤦‍♀️ woman_facepalming 🤷‍♂️ man_shrugging 🤷‍♀️ woman_shrugging ","date":"2019-10-01","objectID":"/2019/emoji-support/:2:9","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"人物角色 图标 代码 图标 代码 👨‍⚕️ man_health_worker 👩‍⚕️ woman_health_worker 👨‍🎓 man_student 👩‍🎓 woman_student 👨‍🏫 man_teacher 👩‍🏫 woman_teacher 👨‍⚖️ man_judge 👩‍⚖️ woman_judge 👨‍🌾 man_farmer 👩‍🌾 woman_farmer 👨‍🍳 man_cook 👩‍🍳 woman_cook 👨‍🔧 man_mechanic 👩‍🔧 woman_mechanic 👨‍🏭 man_factory_worker 👩‍🏭 woman_factory_worker 👨‍💼 man_office_worker 👩‍💼 woman_office_worker 👨‍🔬 man_scientist 👩‍🔬 woman_scientist 👨‍💻 man_technologist 👩‍💻 woman_technologist 👨‍🎤 man_singer 👩‍🎤 woman_singer 👨‍🎨 man_artist 👩‍🎨 woman_artist 👨‍✈️ man_pilot 👩‍✈️ woman_pilot 👨‍🚀 man_astronaut 👩‍🚀 woman_astronaut 👨‍🚒 man_firefighter 👩‍🚒 woman_firefighter 👮‍♂️ cop policeman 👮‍♀️ policewoman 🕵 detective male_detective 🕵️‍♀️ female_detective 💂‍♂️ guardsman 💂‍♀️ guardswoman 👷‍♂️ construction_worker construction_worker_man 👷‍♀️ construction_worker_woman 🤴 prince 👸 princess 👳‍♂️ man_with_turban 👳‍♀️ woman_with_turban 👲 man_with_gua_pi_mao 🤵‍♂️ man_in_tuxedo 👰 bride_with_veil 🤰 pregnant_woman ","date":"2019-10-01","objectID":"/2019/emoji-support/:2:10","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"幻想的人物 图标 代码 图标 代码 👼 angel 🎅 santa 🤶 mrs_claus ","date":"2019-10-01","objectID":"/2019/emoji-support/:2:11","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"人物活动 图标 代码 图标 代码 💆‍♀️ massage massage_woman 💆‍♂️ massage_man 💇‍♀️ haircut haircut_woman 💇‍♂️ haircut_man 🚶‍♂️ walking walking_man 🚶‍♀️ walking_woman 🏃‍♂️ runner running running_man 🏃‍♀️ running_woman 💃 dancer 🕺 man_dancing 🕴️ business_suit_levitating 👯‍♀️ dancers dancing_women 👯‍♂️ dancing_men ","date":"2019-10-01","objectID":"/2019/emoji-support/:2:12","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"体育 图标 代码 图标 代码 🤺 person_fencing 🏇 horse_racing ⛷️ skier 🏂 snowboarder 🏌️‍♂️ golfing_man 🏌️‍♀️ golfing_woman 🏄‍♂️ surfer surfing_man 🏄‍♀️ surfing_woman 🚣‍♂️ rowboat rowing_man 🚣‍♀️ rowing_woman 🏊‍♂️ swimmer swimming_man 🏊‍♀️ swimming_woman ⛹️‍♂️ basketball_man ⛹️‍♀️ basketball_woman 🏋️‍♂️ weight_lifting_man 🏋️‍♀️ weight_lifting_woman 🚴‍♂️ bicyclist biking_man 🚴‍♀️ biking_woman 🚵‍♂️ mountain_bicyclist mountain_biking_man 🚵‍♀️ mountain_biking_woman 🤸‍♂️ man_cartwheeling 🤸‍♀️ woman_cartwheeling 🤼‍♂️ men_wrestling 🤼‍♀️ women_wrestling 🤽‍♂️ man_playing_water_polo 🤽‍♀️ woman_playing_water_polo 🤾‍♂️ man_playing_handball 🤾‍♀️ woman_playing_handball 🤹‍♂️ man_juggling 🤹‍♀️ woman_juggling ","date":"2019-10-01","objectID":"/2019/emoji-support/:2:13","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"休息 图标 代码 图标 代码 🛀 bath 🛌 sleeping_bed ","date":"2019-10-01","objectID":"/2019/emoji-support/:2:14","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"家庭 图标 代码 图标 代码 👭 two_women_holding_hands 👫 couple 👬 two_men_holding_hands 👩‍❤️‍💋‍👨 couplekiss_man_woman 👨‍❤️‍💋‍👨 couplekiss_man_man 👩‍❤️‍💋‍👩 couplekiss_woman_woman 👩‍❤️‍👨 couple_with_heart couple_with_heart_woman_man 👨‍❤️‍👨 couple_with_heart_man_man 👩‍❤️‍👩 couple_with_heart_woman_woman 👨‍👩‍👦 family family_man_woman_boy 👨‍👩‍👧 family_man_woman_girl 👨‍👩‍👧‍👦 family_man_woman_girl_boy 👨‍👩‍👦‍👦 family_man_woman_boy_boy 👨‍👩‍👧‍👧 family_man_woman_girl_girl 👨‍👨‍👦 family_man_man_boy 👨‍👨‍👧 family_man_man_girl 👨‍👨‍👧‍👦 family_man_man_girl_boy 👨‍👨‍👦‍👦 family_man_man_boy_boy 👨‍👨‍👧‍👧 family_man_man_girl_girl 👩‍👩‍👦 family_woman_woman_boy 👩‍👩‍👧 family_woman_woman_girl 👩‍👩‍👧‍👦 family_woman_woman_girl_boy 👩‍👩‍👦‍👦 family_woman_woman_boy_boy 👩‍👩‍👧‍👧 family_woman_woman_girl_girl 👨‍👦 family_man_boy 👨‍👦‍👦 family_man_boy_boy 👨‍👧 family_man_girl 👨‍👧‍👦 family_man_girl_boy 👨‍👧‍👧 family_man_girl_girl 👩‍👦 family_woman_boy 👩‍👦‍👦 family_woman_boy_boy 👩‍👧 family_woman_girl 👩‍👧‍👦 family_woman_girl_boy 👩‍👧‍👧 family_woman_girl_girl ","date":"2019-10-01","objectID":"/2019/emoji-support/:2:15","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"人物符号 图标 代码 图标 代码 🗣 speaking_head 👤 bust_in_silhouette 👥 busts_in_silhouette 👣 footprints ","date":"2019-10-01","objectID":"/2019/emoji-support/:2:16","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"动物与自然 ","date":"2019-10-01","objectID":"/2019/emoji-support/:3:0","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"哺乳动物 图标 代码 图标 代码 🐵 monkey_face 🐒 monkey 🦍 gorilla 🐶 dog 🐕 dog2 🐩 poodle 🐺 wolf 🦊 fox_face 🐱 cat 🐈 cat2 🦁 lion 🐯 tiger 🐅 tiger2 🐆 leopard 🐴 horse 🐎 racehorse 🦄 unicorn 🦌 deer 🐮 cow 🐂 ox 🐃 water_buffalo 🐄 cow2 🐷 pig 🐖 pig2 🐗 boar 🐽 pig_nose 🐏 ram 🐑 sheep 🐐 goat 🐪 dromedary_camel 🐫 camel 🐘 elephant 🦏 rhinoceros 🐭 mouse 🐁 mouse2 🐀 rat 🐹 hamster 🐰 rabbit 🐇 rabbit2 🐿️ chipmunk 🦇 bat 🐻 bear 🐨 koala 🐼 panda_face 🐾 feet paw_prints ","date":"2019-10-01","objectID":"/2019/emoji-support/:3:1","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"鸟类 图标 代码 图标 代码 🦃 turkey 🐔 chicken 🐓 rooster 🐣 hatching_chick 🐤 baby_chick 🐥 hatched_chick 🐦 bird 🐧 penguin 🕊 dove 🦅 eagle 🦆 duck 🦉 owl ","date":"2019-10-01","objectID":"/2019/emoji-support/:3:2","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"两栖动物 icon code icon code 🐸 frog ","date":"2019-10-01","objectID":"/2019/emoji-support/:3:3","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"爬虫类 图标 代码 图标 代码 🐊 crocodile 🐢 turtle 🦎 lizard 🐍 snake 🐲 dragon_face 🐉 dragon ","date":"2019-10-01","objectID":"/2019/emoji-support/:3:4","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"海洋动物 图标 代码 图标 代码 🐳 whale 🐋 whale2 🐬 dolphin flipper 🐟 fish 🐠 tropical_fish 🐡 blowfish 🦈 shark 🐙 octopus 🐚 shell ","date":"2019-10-01","objectID":"/2019/emoji-support/:3:5","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"虫类 图标 代码 图标 代码 🐌 snail 🦋 butterfly 🐛 bug 🐜 ant 🐝 bee honeybee 🪲 beetle 🕷️ spider 🕸️ spider_web 🦂 scorpion ","date":"2019-10-01","objectID":"/2019/emoji-support/:3:6","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"花类植物 图标 代码 图标 代码 💐 bouquet 🌸 cherry_blossom 💮 white_flower 🏵️ rosette 🌹 rose 🥀 wilted_flower 🌺 hibiscus 🌻 sunflower 🌼 blossom 🌷 tulip ","date":"2019-10-01","objectID":"/2019/emoji-support/:3:7","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"其它植物 图标 代码 图标 代码 🌱 seedling 🌲 evergreen_tree 🌳 deciduous_tree 🌴 palm_tree 🌵 cactus 🌾 ear_of_rice 🌿 herb ☘️ shamrock 🍀 four_leaf_clover 🍁 maple_leaf 🍂 fallen_leaf 🍃 leaves ","date":"2019-10-01","objectID":"/2019/emoji-support/:3:8","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"食物与饮料 ","date":"2019-10-01","objectID":"/2019/emoji-support/:4:0","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"水果 图标 代码 图标 代码 🍇 grapes 🍈 melon 🍉 watermelon 🍊 mandarin orange tangerine 🍋 lemon 🍌 banana 🍍 pineapple 🍎 apple 🍏 green_apple 🍐 pear 🍑 peach 🍒 cherries 🍓 strawberry 🥝 kiwi_fruit 🍅 tomato ","date":"2019-10-01","objectID":"/2019/emoji-support/:4:1","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"蔬菜 图标 代码 图标 代码 🥑 avocado 🍆 eggplant 🥔 potato 🥕 carrot 🌽 corn 🌶️ hot_pepper 🥒 cucumber 🍄 mushroom 🥜 peanuts 🌰 chestnut ","date":"2019-10-01","objectID":"/2019/emoji-support/:4:2","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"快餐 图标 代码 图标 代码 🍞 bread 🥐 croissant 🥖 baguette_bread 🥞 pancakes 🧀 cheese 🍖 meat_on_bone 🍗 poultry_leg 🥓 bacon 🍔 hamburger 🍟 fries 🍕 pizza 🌭 hotdog 🌮 taco 🌯 burrito 🥙 stuffed_flatbread 🥚 egg 🍳 fried_egg 🥘 shallow_pan_of_food 🍲 stew 🥗 green_salad 🍿 popcorn ","date":"2019-10-01","objectID":"/2019/emoji-support/:4:3","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"亚洲食物 图标 代码 图标 代码 🍱 bento 🍘 rice_cracker 🍙 rice_ball 🍚 rice 🍛 curry 🍜 ramen 🍝 spaghetti 🍠 sweet_potato 🍢 oden 🍣 sushi 🍤 fried_shrimp 🍥 fish_cake 🍡 dango ","date":"2019-10-01","objectID":"/2019/emoji-support/:4:4","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"海鲜 图标 代码 图标 代码 🦀 crab 🦐 shrimp 🦑 squid ","date":"2019-10-01","objectID":"/2019/emoji-support/:4:5","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"甜点 图标 代码 图标 代码 🍦 icecream 🍧 shaved_ice 🍨 ice_cream 🍩 doughnut 🍪 cookie 🎂 birthday 🍰 cake 🍫 chocolate_bar 🍬 candy 🍭 lollipop 🍮 custard 🍯 honey_pot ","date":"2019-10-01","objectID":"/2019/emoji-support/:4:6","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"饮料 图标 代码 图标 代码 🍼 baby_bottle 🥛 milk_glass ☕ coffee 🍵 tea 🍶 sake 🍾 champagne 🍷 wine_glass 🍸 cocktail 🍹 tropical_drink 🍺 beer 🍻 beers 🥂 clinking_glasses 🥃 tumbler_glass ","date":"2019-10-01","objectID":"/2019/emoji-support/:4:7","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"餐具 图标 代码 图标 代码 🍽️ plate_with_cutlery 🍴 fork_and_knife 🥄 spoon 🔪 hocho knife 🏺 amphora ","date":"2019-10-01","objectID":"/2019/emoji-support/:4:8","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"旅游与地理 ","date":"2019-10-01","objectID":"/2019/emoji-support/:5:0","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"地图 图标 代码 图标 代码 🌍 earth_africa 🌎 earth_americas 🌏 earth_asia 🌐 globe_with_meridians 🗺️ world_map 🗾 japan ","date":"2019-10-01","objectID":"/2019/emoji-support/:5:1","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"地理现象 图标 代码 图标 代码 🏔 mountain_snow ⛰️ mountain 🌋 volcano 🗻 mount_fuji 🏕️ camping ⛱ beach_umbrella 🏜️ desert 🏝️ desert_island 🏞️ national_park ","date":"2019-10-01","objectID":"/2019/emoji-support/:5:2","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"建筑物 图标 代码 图标 代码 🏟️ stadium 🏛️ classical_building 🏗️ building_construction 🏘 houses 🏚 derelict_house 🏠 house 🏡 house_with_garden 🏢 office 🏣 post_office 🏤 european_post_office 🏥 hospital 🏦 bank 🏨 hotel 🏩 love_hotel 🏪 convenience_store 🏫 school 🏬 department_store 🏭 factory 🏯 japanese_castle 🏰 european_castle 💒 wedding 🗼 tokyo_tower 🗽 statue_of_liberty ","date":"2019-10-01","objectID":"/2019/emoji-support/:5:3","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"宗教建筑 图标 代码 图标 代码 ⛪ church 🕌 mosque 🕍 synagogue ⛩️ shinto_shrine 🕋 kaaba ","date":"2019-10-01","objectID":"/2019/emoji-support/:5:4","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"其它地点 图标 代码 图标 代码 ⛲ fountain ⛺ tent 🌁 foggy 🌃 night_with_stars 🏙️ cityscape 🌄 sunrise_over_mountains 🌅 sunrise 🌆 city_sunset 🌇 city_sunrise 🌉 bridge_at_night ♨️ hotsprings 🎠 carousel_horse 🎡 ferris_wheel 🎢 roller_coaster 💈 barber 🎪 circus_tent ","date":"2019-10-01","objectID":"/2019/emoji-support/:5:5","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"陆路运输 图标 代码 图标 代码 🚂 steam_locomotive 🚃 railway_car 🚄 bullettrain_side 🚅 bullettrain_front 🚆 train2 🚇 metro 🚈 light_rail 🚉 station 🚊 tram 🚝 monorail 🚞 mountain_railway 🚋 train 🚌 bus 🚍 oncoming_bus 🚎 trolleybus 🚐 minibus 🚑 ambulance 🚒 fire_engine 🚓 police_car 🚔 oncoming_police_car 🚕 taxi 🚖 oncoming_taxi 🚗 car red_car 🚘 oncoming_automobile 🚙 blue_car 🚚 truck 🚛 articulated_lorry 🚜 tractor 🏎️ racing_car 🏍 motorcycle 🛵 motor_scooter 🚲 bike 🛴 kick_scooter 🚏 busstop 🛣️ motorway 🛤️ railway_track 🛢️ oil_drum ⛽ fuelpump 🚨 rotating_light 🚥 traffic_light 🚦 vertical_traffic_light 🛑 stop_sign 🚧 construction ","date":"2019-10-01","objectID":"/2019/emoji-support/:5:6","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"水路运输 图标 代码 图标 代码 ⚓ anchor ⛵ boat sailboat 🛶 canoe 🚤 speedboat 🛳️ passenger_ship ⛴️ ferry 🛥️ motor_boat 🚢 ship ","date":"2019-10-01","objectID":"/2019/emoji-support/:5:7","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"空中运输 图标 代码 图标 代码 ✈️ airplane 🛩️ small_airplane 🛫 flight_departure 🛬 flight_arrival 💺 seat 🚁 helicopter 🚟 suspension_railway 🚠 mountain_cableway 🚡 aerial_tramway 🛰️ artificial_satellite 🚀 rocket ","date":"2019-10-01","objectID":"/2019/emoji-support/:5:8","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"旅馆 icon code icon code 🛎️ bellhop_bell ","date":"2019-10-01","objectID":"/2019/emoji-support/:5:9","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"时间 图标 代码 图标 代码 ⌛ hourglass ⏳ hourglass_flowing_sand ⌚ watch ⏰ alarm_clock ⏱️ stopwatch ⏲️ timer_clock 🕰️ mantelpiece_clock 🕛 clock12 🕧 clock1230 🕐 clock1 🕜 clock130 🕑 clock2 🕝 clock230 🕒 clock3 🕞 clock330 🕓 clock4 🕟 clock430 🕔 clock5 🕠 clock530 🕕 clock6 🕡 clock630 🕖 clock7 🕢 clock730 🕗 clock8 🕣 clock830 🕘 clock9 🕤 clock930 🕙 clock10 🕥 clock1030 🕚 clock11 🕦 clock1130 ","date":"2019-10-01","objectID":"/2019/emoji-support/:5:10","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"天空与天气 图标 代码 图标 代码 🌑 new_moon 🌒 waxing_crescent_moon 🌓 first_quarter_moon 🌔 moon waxing_gibbous_moon 🌕 full_moon 🌖 waning_gibbous_moon 🌗 last_quarter_moon 🌘 waning_crescent_moon 🌙 crescent_moon 🌚 new_moon_with_face 🌛 first_quarter_moon_with_face 🌜 last_quarter_moon_with_face 🌡️ thermometer ☀️ sunny 🌝 full_moon_with_face 🌞 sun_with_face ⭐ star 🌟 star2 🌠 stars 🌌 milky_way ☁️ cloud ⛅ partly_sunny ⛈ cloud_with_lightning_and_rain 🌤 sun_behind_small_cloud 🌥 sun_behind_large_cloud 🌦 sun_behind_rain_cloud 🌧 cloud_with_rain 🌨 cloud_with_snow 🌩 cloud_with_lightning 🌪️ tornado 🌫️ fog 🌬 wind_face 🌀 cyclone 🌈 rainbow 🌂 closed_umbrella ☂️ open_umbrella ☂️ umbrella ⛱️ parasol_on_ground ⚡ zap ❄️ snowflake ☃️ snowman_with_snow ☃️ snowman ☄️ comet 🔥 fire 💧 droplet 🌊 ocean ","date":"2019-10-01","objectID":"/2019/emoji-support/:5:11","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"活动 ","date":"2019-10-01","objectID":"/2019/emoji-support/:6:0","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"事件 图标 代码 图标 代码 🎃 jack_o_lantern 🎄 christmas_tree 🎆 fireworks 🎇 sparkler ✨ sparkles 🎈 balloon 🎉 tada 🎊 confetti_ball 🎋 tanabata_tree 🎍 bamboo 🎎 dolls 🎏 flags 🎐 wind_chime 🎑 rice_scene 🎀 ribbon 🎁 gift 🎗️ reminder_ribbon 🎟 tickets 🎫 ticket ","date":"2019-10-01","objectID":"/2019/emoji-support/:6:1","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"奖杯与奖牌 图标 代码 图标 代码 🎖️ medal_military 🏆 trophy 🏅 medal_sports 🥇 1st_place_medal 🥈 2nd_place_medal 🥉 3rd_place_medal ","date":"2019-10-01","objectID":"/2019/emoji-support/:6:2","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"体育运动 图标 代码 图标 代码 ⚽ soccer ⚾ baseball 🏀 basketball 🏐 volleyball 🏈 football 🏉 rugby_football 🎾 tennis 🎳 bowling 🦗 cricket 🏑 field_hockey 🏒 ice_hockey 🏓 ping_pong 🏸 badminton 🥊 boxing_glove 🥋 martial_arts_uniform 🥅 goal_net ⛳ golf ⛸️ ice_skate 🎣 fishing_pole_and_fish 🎽 running_shirt_with_sash 🎿 ski ","date":"2019-10-01","objectID":"/2019/emoji-support/:6:3","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"游戏 图标 代码 图标 代码 🎯 dart 🎱 8ball 🔮 crystal_ball 🎮 video_game 🕹️ joystick 🎰 slot_machine 🎲 game_die ♠️ spades ♥️ hearts ♦️ diamonds ♣️ clubs 🃏 black_joker 🀄 mahjong 🎴 flower_playing_cards ","date":"2019-10-01","objectID":"/2019/emoji-support/:6:4","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"艺术与工艺 图标 代码 图标 代码 🎭 performing_arts 🖼 framed_picture 🎨 art ","date":"2019-10-01","objectID":"/2019/emoji-support/:6:5","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"物品 ","date":"2019-10-01","objectID":"/2019/emoji-support/:7:0","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"服装 图标 代码 图标 代码 👓 eyeglasses 🕶️ dark_sunglasses 👔 necktie 👕 shirt tshirt 👖 jeans 👗 dress 👘 kimono 👙 bikini 👚 womans_clothes 👛 purse 👜 handbag 👝 pouch 🛍️ shopping 🎒 school_satchel 👞 mans_shoe shoe 👟 athletic_shoe 👠 high_heel 👡 sandal 👢 boot 👑 crown 👒 womans_hat 🎩 tophat 🎓 mortar_board ⛑️ rescue_worker_helmet 📿 prayer_beads 💄 lipstick 💍 ring 💎 gem ","date":"2019-10-01","objectID":"/2019/emoji-support/:7:1","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"声音 图标 代码 图标 代码 🔇 mute 🔈 speaker 🔉 sound 🔊 loud_sound 📢 loudspeaker 📣 mega 📯 postal_horn 🔔 bell 🔕 no_bell ","date":"2019-10-01","objectID":"/2019/emoji-support/:7:2","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"音乐 图标 代码 图标 代码 🎼 musical_score 🎵 musical_note 🎶 notes 🎙️ studio_microphone 🎚️ level_slider 🎛️ control_knobs 🎤 microphone 🎧 headphones 📻 radio ","date":"2019-10-01","objectID":"/2019/emoji-support/:7:3","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"乐器 图标 代码 图标 代码 🎷 saxophone 🎸 guitar 🎹 musical_keyboard 🎺 trumpet 🎻 violin 🥁 drum ","date":"2019-10-01","objectID":"/2019/emoji-support/:7:4","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"电话 图标 代码 图标 代码 📱 iphone 📲 calling ☎️ phone telephone 📞 telephone_receiver 📟 pager 📠 fax ","date":"2019-10-01","objectID":"/2019/emoji-support/:7:5","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"电脑 图标 代码 图标 代码 🔋 battery 🔌 electric_plug 💻 computer 🖥️ desktop_computer 🖨️ printer ⌨️ keyboard 🖱 computer_mouse 🖲️ trackball 💽 minidisc 💾 floppy_disk 💿 cd 📀 dvd ","date":"2019-10-01","objectID":"/2019/emoji-support/:7:6","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"灯光与影像 图标 代码 图标 代码 🎥 movie_camera 🎞️ film_strip 📽️ film_projector 🎬 clapper 📺 tv 📷 camera 📸 camera_flash 📹 video_camera 📼 vhs 🔍 mag 🔎 mag_right 🕯️ candle 💡 bulb 🔦 flashlight 🏮 izakaya_lantern lantern ","date":"2019-10-01","objectID":"/2019/emoji-support/:7:7","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"书与纸张 图标 代码 图标 代码 📔 notebook_with_decorative_cover 📕 closed_book 📖 book open_book 📗 green_book 📘 blue_book 📙 orange_book 📚 books 📓 notebook 📒 ledger 📃 page_with_curl 📜 scroll 📄 page_facing_up 📰 newspaper 🗞️ newspaper_roll 📑 bookmark_tabs 🔖 bookmark 🏷️ label ","date":"2019-10-01","objectID":"/2019/emoji-support/:7:8","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"钱 图标 代码 图标 代码 💰 moneybag 💴 yen 💵 dollar 💶 euro 💷 pound 💸 money_with_wings 💳 credit_card 💹 chart ","date":"2019-10-01","objectID":"/2019/emoji-support/:7:9","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"邮件 图标 代码 图标 代码 ✉️ email envelope 📧 📧 📨 incoming_envelope 📩 envelope_with_arrow 📤 outbox_tray 📥 inbox_tray 📦 package 📫 mailbox 📪 mailbox_closed 📬 mailbox_with_mail 📭 mailbox_with_no_mail 📮 postbox 🗳 ballot_box ","date":"2019-10-01","objectID":"/2019/emoji-support/:7:10","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"书写 图标 代码 图标 代码 ✏️ pencil2 ✒️ black_nib 🖋 fountain_pen 🖊 pen 🖌 paintbrush 🖍 crayon 📝 memo pencil ","date":"2019-10-01","objectID":"/2019/emoji-support/:7:11","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"办公 图标 代码 图标 代码 💼 briefcase 📁 file_folder 📂 open_file_folder 🗂️ card_index_dividers 📅 date 📆 calendar 🗒 spiral_notepad 🗓 spiral_calendar 📇 card_index 📈 chart_with_upwards_trend 📉 chart_with_downwards_trend 📊 bar_chart 📋 clipboard 📌 pushpin 📍 round_pushpin 📎 paperclip 🖇 paperclips 📏 straight_ruler 📐 triangular_ruler ✂️ scissors 🗃️ card_file_box 🗄️ file_cabinet 🗑️ wastebasket ","date":"2019-10-01","objectID":"/2019/emoji-support/:7:12","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"锁 图标 代码 图标 代码 🔒 lock 🔓 unlock 🔏 lock_with_ink_pen 🔐 closed_lock_with_key 🔑 key 🗝️ old_key ","date":"2019-10-01","objectID":"/2019/emoji-support/:7:13","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"工具 图标 代码 图标 代码 🔨 hammer ⛏️ pick ⚒️ hammer_and_pick 🛠️ hammer_and_wrench 🗡 dagger ⚔️ crossed_swords 🔫 gun 🏹 bow_and_arrow 🛡️ shield 🔧 wrench 🔩 nut_and_bolt ⚙️ gear 🗜 clamp ⚖ balance_scale 🔗 link ⛓️ chains ","date":"2019-10-01","objectID":"/2019/emoji-support/:7:14","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"科学 图标 代码 图标 代码 ⚗️ alembic 🔬 microscope 🔭 telescope 🛰️ satellite ","date":"2019-10-01","objectID":"/2019/emoji-support/:7:15","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"医疗 图标 代码 图标 代码 💉 syringe 💊 pill ","date":"2019-10-01","objectID":"/2019/emoji-support/:7:16","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"生活用品 图标 代码 图标 代码 🚪 door 🛏️ bed 🛋️ couch_and_lamp 🚽 toilet 🚿 shower 🛁 bathtub 🛒 shopping_cart ","date":"2019-10-01","objectID":"/2019/emoji-support/:7:17","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"其它物品 图标 代码 图标 代码 🚬 smoking ⚰️ coffin ⚱️ funeral_urn 🗿 moyai ","date":"2019-10-01","objectID":"/2019/emoji-support/:7:18","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"符号 ","date":"2019-10-01","objectID":"/2019/emoji-support/:8:0","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"交通标识 图标 代码 图标 代码 🏧 atm 🚮 put_litter_in_its_place 🚰 potable_water ♿ wheelchair 🚹 mens 🚺 womens 🚻 restroom 🚼 baby_symbol 🚾 wc 🛂 passport_control 🛃 customs 🛄 baggage_claim 🛅 left_luggage ","date":"2019-10-01","objectID":"/2019/emoji-support/:8:1","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"警告 图标 代码 图标 代码 ⚠️ warning 🚸 children_crossing ⛔ no_entry 🚫 no_entry_sign 🚳 no_bicycles 🚭 no_smoking 🚯 do_not_litter 🚱 🚱 🚷 no_pedestrians 📵 no_mobile_phones 🔞 underage ☢ radioactive ☣ biohazard ","date":"2019-10-01","objectID":"/2019/emoji-support/:8:2","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"箭头 图标 代码 图标 代码 ⬆️ arrow_up ↗️ arrow_upper_right ➡️ arrow_right ↘️ arrow_lower_right ⬇️ arrow_down ↙️ arrow_lower_left ⬅️ arrow_left ↖️ arrow_upper_left ↕️ arrow_up_down ↔️ left_right_arrow ↩️ leftwards_arrow_with_hook ↪️ arrow_right_hook ⤴️ arrow_heading_up ⤵️ arrow_heading_down 🔃 arrows_clockwise 🔄 arrows_counterclockwise 🔙 back 🔚 end 🔛 on 🔜 soon 🔝 top ","date":"2019-10-01","objectID":"/2019/emoji-support/:8:3","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"宗教 图标 代码 图标 代码 🛐 place_of_worship ⚛️ atom_symbol 🕉 om ✡️ star_of_david ☸️ wheel_of_dharma ☯️ yin_yang ✝️ latin_cross ☦️ orthodox_cross ☪️ star_and_crescent ☮️ peace_symbol 🕎 menorah 🔯 six_pointed_star ","date":"2019-10-01","objectID":"/2019/emoji-support/:8:4","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"生肖 图标 代码 图标 代码 ♈ aries ♉ taurus ♊ gemini ♋ cancer ♌ leo ♍ virgo ♎ libra ♏ scorpius ♐ sagittarius ♑ capricorn ♒ aquarius ♓ pisces ⛎ ophiuchus ","date":"2019-10-01","objectID":"/2019/emoji-support/:8:5","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"影像符号 图标 代码 图标 代码 🔀 twisted_rightwards_arrows 🔁 repeat 🔂 repeat_one ▶️ arrow_forward ⏩ fast_forward ⏭ next_track_button ⏯ play_or_pause_button ◀️ arrow_backward ⏪ rewind ⏮️ previous_track_button 🔼 arrow_up_small ⏫ arrow_double_up 🔽 arrow_down_small ⏬ arrow_double_down ⏸ pause_button ⏹ stop_button ⏺ record_button 🎦 cinema 🔅 low_brightness 🔆 high_brightness 📶 signal_strength 📳 vibration_mode 📴 mobile_phone_off ","date":"2019-10-01","objectID":"/2019/emoji-support/:8:6","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"数学 图标 代码 图标 代码 ✖️ heavy_multiplication_x ➕ heavy_plus_sign ➖ heavy_minus_sign ➗ heavy_division_sign ","date":"2019-10-01","objectID":"/2019/emoji-support/:8:7","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"标点符号 图标 代码 图标 代码 ‼️ bangbang ⁉️ interrobang ❓ question ❔ grey_question ❕ grey_exclamation ❗ exclamation heavy_exclamation_mark 〰️ wavy_dash ","date":"2019-10-01","objectID":"/2019/emoji-support/:8:8","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"货币 图标 代码 图标 代码 💱 currency_exchange 💲 heavy_dollar_sign ","date":"2019-10-01","objectID":"/2019/emoji-support/:8:9","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"按键符号 图标 代码 图标 代码 #️⃣ hash *️⃣ asterisk 0️⃣ zero 1️⃣ one 2️⃣ two 3️⃣ three 4️⃣ four 5️⃣ five 6️⃣ six 7️⃣ seven 8️⃣ eight 9️⃣ nine 🔟 keycap_ten ","date":"2019-10-01","objectID":"/2019/emoji-support/:8:10","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"字母符号 图标 代码 图标 代码 🔠 capital_abcd 🔡 abcd 🔢 1234 🔣 symbols 🔤 abc 🅰️ a 🆎 ab 🅱️ b 🆑 cl 🆒 cool 🆓 free ℹ️ information_source 🆔 id ⓜ️ m 🆕 new 🆖 ng 🅾️ o2 🆗 ok 🅿️ parking 🆘 sos 🆙 up 🆚 vs 🈁 koko 🈂️ sa 🈷️ u6708 🈶 u6709 🈯 u6307 🉐 ideograph_advantage 🈹 u5272 🈚 u7121 🈲 u7981 🉑 accept 🈸 u7533 🈴 u5408 🈳 u7a7a ㊗️ congratulations ㊙️ secret 🈺 u55b6 🈵 u6e80 ","date":"2019-10-01","objectID":"/2019/emoji-support/:8:11","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"几何符号 图标 代码 图标 代码 🔴 red_circle 🔵 large_blue_circle ⚫ black_circle ⚪ white_circle ⬛ black_large_square ⬜ white_large_square ◼️ black_medium_square ◻️ white_medium_square ◾ black_medium_small_square ◽ white_medium_small_square ▪️ black_small_square ▫️ white_small_square 🔶 large_orange_diamond 🔷 large_blue_diamond 🔸 small_orange_diamond 🔹 small_blue_diamond 🔺 small_red_triangle 🔻 small_red_triangle_down 💠 diamond_shape_with_a_dot_inside 🔘 radio_button 🔳 white_square_button 🔲 black_square_button ","date":"2019-10-01","objectID":"/2019/emoji-support/:8:12","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"其它符合 图标 代码 图标 代码 ♻️ recycle ⚜️ fleur_de_lis 🔱 trident 📛 name_badge 🔰 beginner ⭕ o ✅ white_check_mark ☑️ ballot_box_with_check ✔️ heavy_check_mark ❌ x ❎ negative_squared_cross_mark ➰ curly_loop ➿ loop 〽️ part_alternation_mark ✳️ eight_spoked_asterisk ✴️ eight_pointed_black_star ❇️ sparkle ©️ copyright ®️ registered ™️ tm ","date":"2019-10-01","objectID":"/2019/emoji-support/:8:13","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"旗帜 ","date":"2019-10-01","objectID":"/2019/emoji-support/:9:0","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"常用旗帜 图标 代码 图标 代码 🏁 checkered_flag 🚩 triangular_flag_on_post 🎌 crossed_flags 🏴 black_flag 🏳 white_flag 🏳️‍🌈 rainbow_flag ","date":"2019-10-01","objectID":"/2019/emoji-support/:9:1","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":["Markdown"],"content":"国家和地区旗帜 图标 代码 图标 代码 🇦🇩 andorra 🇦🇪 united_arab_emirates 🇦🇫 afghanistan 🇦🇬 antigua_barbuda 🇦🇮 anguilla 🇦🇱 albania 🇦🇲 armenia 🇦🇴 angola 🇦🇶 antarctica 🇦🇷 argentina 🇦🇸 american_samoa 🇦🇹 austria 🇦🇺 australia 🇦🇼 aruba 🇦🇽 aland_islands 🇦🇿 azerbaijan 🇧🇦 bosnia_herzegovina 🇧🇧 barbados 🇧🇩 bangladesh 🇧🇪 belgium 🇧🇫 burkina_faso 🇧🇬 bulgaria 🇧🇭 bahrain 🇧🇮 burundi 🇧🇯 benin 🇧🇱 st_barthelemy 🇧🇲 bermuda 🇧🇳 brunei 🇧🇴 bolivia 🇧🇶 caribbean_netherlands 🇧🇷 brazil 🇧🇸 bahamas 🇧🇹 bhutan 🇧🇼 botswana 🇧🇾 belarus 🇧🇿 belize 🇨🇦 canada 🇨🇨 cocos_islands 🇨🇩 congo_kinshasa 🇨🇫 central_african_republic 🇨🇬 congo_brazzaville 🇨🇭 switzerland 🇨🇮 cote_divoire 🇨🇰 cook_islands 🇨🇱 chile 🇨🇲 cameroon 🇨🇳 cn 🇨🇴 colombia 🇨🇷 costa_rica 🇨🇺 cuba 🇨🇻 cape_verde 🇨🇼 curacao 🇨🇽 christmas_island 🇨🇾 cyprus 🇨🇿 czech_republic 🇩🇪 de 🇩🇯 djibouti 🇩🇰 denmark 🇩🇲 dominica 🇩🇴 dominican_republic 🇩🇿 algeria 🇪🇨 ecuador 🇪🇪 estonia 🇪🇬 egypt 🇪🇭 western_sahara 🇪🇷 eritrea 🇪🇸 es 🇪🇹 ethiopia 🇪🇺 eu european_union 🇫🇮 finland 🇫🇯 fiji 🇫🇰 falkland_islands 🇫🇲 micronesia 🇫🇴 faroe_islands 🇫🇷 fr 🇬🇦 gabon 🇬🇧 gb uk 🇬🇩 grenada 🇬🇪 georgia 🇬🇫 french_guiana 🇬🇬 guernsey 🇬🇭 ghana 🇬🇮 gibraltar 🇬🇱 greenland 🇬🇲 gambia 🇬🇳 guinea 🇬🇵 guadeloupe 🇬🇶 equatorial_guinea 🇬🇷 greece 🇬🇸 south_georgia_south_sandwich_islands 🇬🇹 guatemala 🇬🇺 guam 🇬🇼 guinea_bissau 🇬🇾 guyana 🇭🇰 hong_kong 🇭🇳 honduras 🇭🇷 croatia 🇭🇹 haiti 🇭🇺 hungary 🇮🇨 canary_islands 🇮🇩 indonesia 🇮🇪 ireland 🇮🇱 israel 🇮🇲 isle_of_man 🇮🇳 india 🇮🇴 british_indian_ocean_territory 🇮🇶 iraq 🇮🇷 iran 🇮🇸 iceland 🇮🇹 it 🇯🇪 jersey 🇯🇲 jamaica 🇯🇴 jordan 🇯🇵 jp 🇰🇪 kenya 🇰🇬 kyrgyzstan 🇰🇭 cambodia 🇰🇮 kiribati 🇰🇲 comoros 🇰🇳 st_kitts_nevis 🇰🇵 north_korea 🇰🇷 kr 🇰🇼 kuwait 🇰🇾 cayman_islands 🇰🇿 kazakhstan 🇱🇦 laos 🇱🇧 lebanon 🇱🇨 st_lucia 🇱🇮 liechtenstein 🇱🇰 sri_lanka 🇱🇷 liberia 🇱🇸 lesotho 🇱🇹 lithuania 🇱🇺 luxembourg 🇱🇻 latvia 🇱🇾 libya 🇲🇦 morocco 🇲🇨 monaco 🇲🇩 moldova 🇲🇪 montenegro 🇲🇬 madagascar 🇲🇭 marshall_islands 🇲🇰 macedonia 🇲🇱 mali 🇲🇲 myanmar 🇲🇳 mongolia 🇲🇴 macau 🇲🇵 northern_mariana_islands 🇲🇶 martinique 🇲🇷 mauritania 🇲🇸 montserrat 🇲🇹 malta 🇲🇺 mauritius 🇲🇻 maldives 🇲🇼 malawi 🇲🇽 mexico 🇲🇾 malaysia 🇲🇿 mozambique 🇳🇦 namibia 🇳🇨 new_caledonia 🇳🇪 niger 🇳🇫 norfolk_island 🇳🇬 nigeria 🇳🇮 nicaragua 🇳🇱 netherlands 🇳🇴 norway 🇳🇵 nepal 🇳🇷 nauru 🇳🇺 niue 🇳🇿 new_zealand 🇴🇲 oman 🇵🇦 panama 🇵🇪 peru 🇵🇫 french_polynesia 🇵🇬 papua_new_guinea 🇵🇭 philippines 🇵🇰 pakistan 🇵🇱 poland 🇵🇲 st_pierre_miquelon 🇵🇳 pitcairn_islands 🇵🇷 puerto_rico 🇵🇸 palestinian_territories 🇵🇹 portugal 🇵🇼 palau 🇵🇾 paraguay 🇶🇦 qatar 🇷🇪 reunion 🇷🇴 romania 🇷🇸 serbia 🇷🇺 ru 🇷🇼 rwanda 🇸🇦 saudi_arabia 🇸🇧 solomon_islands 🇸🇨 seychelles 🇸🇩 sudan 🇸🇪 sweden 🇸🇬 singapore 🇸🇭 st_helena 🇸🇮 slovenia 🇸🇰 slovakia 🇸🇱 sierra_leone 🇸🇲 san_marino 🇸🇳 senegal 🇸🇴 somalia 🇸🇷 suriname 🇸🇸 south_sudan 🇸🇹 sao_tome_principe 🇸🇻 el_salvador 🇸🇽 sint_maarten 🇸🇾 syria 🇸🇿 swaziland 🇹🇨 turks_caicos_islands 🇹🇩 chad 🇹🇫 french_southern_territories 🇹🇬 togo 🇹🇭 thailand 🇹🇯 tajikistan 🇹🇰 tokelau 🇹🇱 timor_leste 🇹🇲 turkmenistan 🇹🇳 tunisia 🇹🇴 tonga 🇹🇷 tr 🇹🇹 trinidad_tobago 🇹🇻 tuvalu 🇹🇼 taiwan 🇹🇿 tanzania 🇺🇦 ukraine 🇺🇬 uganda 🇺🇸 us 🇺🇾 uruguay 🇺🇿 uzbekistan 🇻🇦 vatican_city 🇻🇨 st_vincent_grenadines 🇻🇪 venezuela 🇻🇬 british_virgin_islands 🇻🇮 us_virgin_islands 🇻🇳 vietnam 🇻🇺 vanuatu 🇼🇫 wallis_futuna 🇼🇸 samoa 🇽🇰 kosovo 🇾🇪 yemen 🇾🇹 mayotte 🇿🇦 south_africa 🇿🇲 zambia 🇿🇼 zimbabwe ","date":"2019-10-01","objectID":"/2019/emoji-support/:9:2","tags":["emoji"],"title":"Emoji 支持","uri":"/2019/emoji-support/"},{"categories":null,"content":"作者很懒，什么都没有留下，敬请期待。。。 ","date":"2021-06-24","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"First Posts ","date":"2021-06-24","objectID":"/2021/first_post/:0:0","tags":null,"title":"First_post","uri":"/2021/first_post/"},{"categories":null,"content":"1. 嵌入YouTube视频 ","date":"2021-06-24","objectID":"/2021/first_post/:0:1","tags":null,"title":"First_post","uri":"/2021/first_post/"},{"categories":null,"content":"2. 嵌入Bilibili视频 ","date":"2021-06-24","objectID":"/2021/first_post/:0:2","tags":null,"title":"First_post","uri":"/2021/first_post/"},{"categories":null,"content":"3. 流程图支持 sequenceDiagram participant Alices participant Bob Alice-John: Hello John, how are you? loop Healthcheck John-John: Fight against hypochondria end Note right of John: Rational thoughts prevail... John--Alice: Great! John-Bob: How about you? Bodb--John: Jolly good! ","date":"2021-06-24","objectID":"/2021/first_post/:0:3","tags":null,"title":"First_post","uri":"/2021/first_post/"}]